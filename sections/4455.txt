var __v="\n\u003cpre class='prettyprint linenums'\u003epackage transport\n\nimport (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n)\n\ntype authInfo struct {\n}\n\nfunc (authInfo) AuthType() string {\n\treturn \"wrapper transport auth\"\n}\n\ntype transportCredentials struct {\n\tisServer bool\n\tpwd      string\n\tbase     credentials.TransportCredentials\n}\n\nfunc NewServerCreds(pwd string, base credentials.TransportCredentials) credentials.TransportCredentials {\n\treturn \u0026amp;transportCredentials{\n\t\tisServer: true,\n\t\tpwd:      pwd,\n\t\tbase:     base,\n\t}\n}\nfunc NewClientCreds(pwd string, base credentials.TransportCredentials) credentials.TransportCredentials {\n\treturn \u0026amp;transportCredentials{\n\t\tisServer: false,\n\t\tpwd:      pwd,\n\t\tbase:     base,\n\t}\n}\n\n//實現 客戶端 向 服務器 請求認證\nfunc (t *transportCredentials) ClientHandshake(ctx context.Context, str string, c net.Conn) (net.Conn, credentials.AuthInfo, error) {\n\tfmt.Println(\"ClientHandshake\")\n\tif t.base == nil {\n\t\treturn t.clientHandshake(ctx, str, c)\n\t}\n\n\t//進行原始 驗證\n\tc0, i, e := t.base.ClientHandshake(ctx, str, c)\n\tif e != nil {\n\t\treturn c0, i, e\n\t}\n\treturn t.clientHandshake(ctx, str, c0)\n}\nfunc (t *transportCredentials) clientHandshake(ctx context.Context, str string, c net.Conn) (net.Conn, credentials.AuthInfo, error) {\n\t//向 服務器 發送 密碼\n\tb := make([]byte, 2+len(t.pwd))\n\tbinary.LittleEndian.PutUint16(b, 2+uint16(len(t.pwd)))\n\tcopy(b[2:], []byte(t.pwd))\n\t_, e := c.Write(b)\n\tif e != nil {\n\t\tlog.Println(e)\n\n\t\treturn nil, nil, e\n\t}\n\t//獲取 服務器 確認\n\tb, e = t.getMessage(c)\n\tif e != nil {\n\t\tlog.Println(e)\n\n\t\treturn nil, nil, e\n\t} else if len(b) != 1 || b[0] == 0 {\n\t\te = errors.New(\"passwd not match\")\n\t\tlog.Println(e)\n\t\treturn nil, nil, e\n\t}\n\tfmt.Println(\"c yes\", b)\n\t//返回 net.Conn\n\treturn c, authInfo{}, nil\n}\n\n//實現 服務器 驗證 客戶端\nfunc (t *transportCredentials) ServerHandshake(c net.Conn) (net.Conn, credentials.AuthInfo, error) {\n\tfmt.Println(\"ServerHandshake\", t.base)\n\tif t.base == nil {\n\t\treturn t.serverHandshake(c)\n\t}\n\t//進行原始 驗證\n\tc0, i, e := t.base.ServerHandshake(c)\n\tif e != nil {\n\t\treturn c0, i, e\n\t}\n\treturn t.serverHandshake(c0)\n}\nfunc (t *transportCredentials) serverHandshake(c net.Conn) (net.Conn, credentials.AuthInfo, error) {\n\n\t//獲取 客戶端 發來的 驗證\n\tb, e := t.getMessage(c)\n\tif e != nil {\n\t\tlog.Println(e)\n\n\t\treturn nil, nil, e\n\t}\n\n\t//驗證 密碼\n\tif string(b) != t.pwd {\n\t\t//通知 客戶端 失敗\n\t\tb = make([]byte, 3)\n\t\tbinary.LittleEndian.PutUint16(b, 3)\n\t\tb[2] = 0\n\t\t_, e = c.Write(b)\n\t\tif e != nil {\n\t\t\tlog.Println(e)\n\n\t\t\treturn nil, nil, e\n\t\t}\n\t\tlog.Println(\"pwd not match\")\n\n\t\treturn nil, nil, errors.New(\"pwd not match\")\n\t}\n\n\t//通知 客戶端 成功\n\tb = make([]byte, 3)\n\tbinary.LittleEndian.PutUint16(b, 3)\n\tb[2] = 1\n\t_, e = c.Write(b)\n\tif e != nil {\n\t\tlog.Println(e)\n\n\t\treturn nil, nil, e\n\t}\n\tlog.Println(\"s yes\")\n\t//返回 net.Conn\n\treturn c, authInfo{}, nil\n}\n\nfunc (t *transportCredentials) Info() credentials.ProtocolInfo {\n\tfmt.Println(\"Info\")\n\treturn credentials.ProtocolInfo{}\n}\nfunc (t *transportCredentials) Clone() credentials.TransportCredentials {\n\tfmt.Println(\"Clone\")\n\ttn := *t\n\treturn \u0026amp;tn\n}\n\nfunc (t *transportCredentials) OverrideServerName(string) error {\n\tfmt.Println(\"OverrideServerName\")\n\treturn nil\n}\nfunc (t *transportCredentials) getMessage(r io.Reader) (rs []byte, e error) {\n\tb := make([]byte, 1024)\n\tpos := 0\n\tvar size int\n\tvar n int\n\tfor {\n\t\t//讀取 header\n\t\tn, e = r.Read(b[pos:])\n\t\tif e != nil {\n\t\t\treturn\n\t\t}\n\t\tpos += n\n\t\tif pos \u0026lt; 2 {\n\t\t\t//wait header\n\t\t\tcontinue\n\t\t}\n\n\t\tif size == 0 {\n\t\t\t//獲取 長度\n\t\t\tsize = int(binary.LittleEndian.Uint16(b))\n\t\t\tif size \u0026lt; 2 || size \u0026gt; 1024 {\n\t\t\t\te = errors.New(\"bad msg len\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tb = b[:size]\n\t\t}\n\t\tif pos \u0026lt; size {\n\t\t\t//wait body\n\t\t\tcontinue\n\t\t}\n\t\trs = b[2:]\n\t\tbreak\n\t}\n\treturn\n}\n\u003c/pre\u003e"