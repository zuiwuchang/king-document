var __v="\u003cpre class=\"prettyprint linenums\"\u003efinal String KEY_ALGORITHM=\"AES\";\t\t\t\t\t//算法名称\nfinal String CIPHER_ALGORITHM=KEY_ALGORITHM+\"/CBC/PKCS5Padding\";\t//工作模式 和 填充方式\n\t\t\t\t\t\t\nString str=\"this is \"+KEY_ALGORITHM;\n//不同算法iv长度是不同的 最好是随便填 然后等编译器报错 就会提示需要的iv长度\nbyte[] iv = \"0123456789abcdef\".getBytes();\t//iv\t\nSystem.out.println(\"原文:\"+str);\n\t\t\t\t\t\t\n//产生密钥\nKeyGenerator kg=KeyGenerator.getInstance(KEY_ALGORITHM,\"BC\");\nkg.init(128);\t\t\t\t\t\t//传入key位数\nSecretKey secretKey = kg.generateKey();\t\t\t//产生key\n//byte[] key=secretKey.getEncoded();\t\t\t//保存key的byte数据\n\t\t\t\t\t\t\n//加密 \nCipher cipher=Cipher.getInstance(CIPHER_ALGORITHM,\"BC\");//BC 从BouncyCastle获取算法 不填为从sun库\nIvParameterSpec param = new IvParameterSpec(iv);\t\t//初始化向量iv\ncipher.init(Cipher.ENCRYPT_MODE, secretKey,param);\t\t//产生加密器\nbyte[] data=cipher.doFinal(str.getBytes());\t\t//加密\nstr=new String(Hex.encode(data));\nSystem.out.println(\"密文:\"+str);\n\t\t\t\t\t\t\n//解密\n//SecretKey secretKey=new SecretKeySpec(key,KEY_ALGORITHM);\t//由保存的key byte数据恢复key\ncipher=Cipher.getInstance(CIPHER_ALGORITHM,\"BC\");\n//IvParameterSpec param = new IvParameterSpec(iv);\ncipher.init(Cipher.DECRYPT_MODE, secretKey,param);\t\t\t//产生解密器\ndata=cipher.doFinal(data);\t\t\t\t\t//解密\nstr=new String(data);\nSystem.out.println(\"解密:\"+str);\u003c/pre\u003e"