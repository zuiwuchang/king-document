var __v="\n\u003cpre class='prettyprint linenums'\u003e#include \u0026lt;iostream\u0026gt;\n\n#include \u0026lt;boost/asio.hpp\u0026gt;\n#include \u0026lt;boost/thread.hpp\u0026gt;\n#include \u0026lt;boost/bind.hpp\u0026gt;\n#include \u0026lt;boost/asio/spawn.hpp\u0026gt;\n#include \u0026lt;boost/smart_ptr.hpp\u0026gt;\n\ntypedef boost::asio::io_service io_service_t;\ntypedef boost::asio::ip::tcp::acceptor acceptor_t;\ntypedef boost::asio::ip::tcp::socket socket_t;\ntypedef boost::shared_ptr\u0026lt;socket_t\u0026gt; socket_spt;\n\n#define READ_BUFFER\t1024\n\nvoid coroutine_accept(acceptor_t\u0026amp; acceptor,boost::asio::yield_context ctx);\nvoid coroutine_read(socket_spt sp,boost::asio::yield_context ctx);\nint _tmain(int argc, _TCHAR* argv[])\n{\n\ttry\n\t{\n\t//asio 服務\n\tio_service_t service;\n\n\t//接收器\n\tacceptor_t acceptor(service,boost::asio::ip::tcp::endpoint(boost::asio::ip::address::from_string(\"0.0.0.0\"),1102));\n\n\t//啓動 接收連接 coroutine\n\tboost::asio::spawn(service,boost::bind(coroutine_accept,boost::ref(acceptor),_1));\n\t\n\n\t//運行asio服務\n\tservice.run();\n\t}\n\tcatch(const boost::system::system_error\u0026amp; se)\n\t{\n\t\tstd::cout\u0026lt;\u0026lt;se.what()\u0026lt;\u0026lt;\"\\n\";\n\t\tstd::system(\"pause\");\n\t}\n\treturn 0;\n}\n\nvoid coroutine_accept(acceptor_t\u0026amp; acceptor,boost::asio::yield_context ctx)\n{\n\twhile(true)\n\t{\n\t\tboost::system::error_code ec;\n\t\tio_service_t\u0026amp; service = acceptor.get_io_service();\n\t\ttry\n\t\t{\n\t\t\tsocket_spt sp = boost::make_shared\u0026lt;socket_t\u0026gt;(service);\n\t\t\tacceptor.async_accept(*sp,ctx[ec]);\n\t\t\tacceptor.get_io_service();\n\t\t\tif(ec)\n\t\t\t{\n\t\t\t\t//錯誤\n\t\t\t\tstd::cout\u0026lt;\u0026lt;ec\u0026lt;\u0026lt;\"\\n\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//爲 socket 啓動 通信 coroutine\n\t\t\t\tboost::asio::spawn(service,boost::bind(coroutine_read,sp,_1));\n\t\t\t}\n\n\t\t}\n\t\tcatch(const std::bad_alloc\u0026amp; e)\n\t\t{\n\t\t\tstd::cout\u0026lt;\u0026lt;e.what()\u0026lt;\u0026lt;\"\\n\";\n\t\t}\n\t}\n}\n\nvoid coroutine_read(socket_spt sp,boost::asio::yield_context ctx)\n{\n\tboost::system::error_code ec;\n\tsocket_t\u0026amp; s = *sp;\n#ifdef _DEBUG\n\tstd::cout\u0026lt;\u0026lt;\"one in  : \"\u0026lt;\u0026lt;s.remote_endpoint(ec)\u0026lt;\u0026lt;\"\\n\";\n#endif\n\ttry\n\t{\n\t\t//讀取消息\n\t\tstd::string str;\n\t\tchar buffer[READ_BUFFER];\n\t\twhile(true)\n\t\t{\n\t\t\t//接收消息 yield\n\t\t\tstd::size_t n = s.async_read_some(boost::asio::buffer(buffer,1024),ctx);\n\t\t\tstr.insert(str.end(),buffer,buffer+n);\n\t\t\tif(buffer[n-1] == '\\n')\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#ifdef _DEBUG\n\t\tstd::cout\u0026lt;\u0026lt;s.remote_endpoint(ec)\u0026lt;\u0026lt;\" : \"\u0026lt;\u0026lt;str\u0026lt;\u0026lt;\"\\n\";\n#endif\n\t\t//回顯消息\n\t\ts.async_write_some(boost::asio::buffer(str),ctx);\n\n\t\t//退出 關閉 socket\n\t}\n\tcatch(const boost::system::system_error\u0026amp; se)\n\t{\n\t\tstd::cout\u0026lt;\u0026lt;se.what()\u0026lt;\u0026lt;\"\\n\";\n\t}\n#ifdef _DEBUG\n\tstd::cout\u0026lt;\u0026lt;\"one out : \"\u0026lt;\u0026lt;s.remote_endpoint(ec)\u0026lt;\u0026lt;\"\\n\";\n#endif\n\ts.shutdown(socket_t::shutdown_both,ec);\n\ts.close(ec);\n}\u003c/pre\u003e"