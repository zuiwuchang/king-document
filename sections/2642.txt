var __v="\u003cpre class=\"prettyprint linenums\"\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstdint\u0026gt;\n\n#include \u0026lt;boost/asio.hpp\u0026gt;\n#include \u0026lt;boost/thread.hpp\u0026gt;\n#include \u0026lt;boost/bind.hpp\u0026gt;\n#include \u0026lt;boost/asio/spawn.hpp\u0026gt;\n#include \u0026lt;boost/smart_ptr.hpp\u0026gt;\n\n#define LISTEN_ADDRESS \"0.0.0.0\"\n#define LISTEN_PORT 8080\n#define BUFFER_SIZE 1024\n\ntypedef boost::asio::io_service io_service_t;\ntypedef boost::asio::ip::tcp::acceptor acceptor_t;\ntypedef boost::asio::ip::tcp::socket socket_t;\ntypedef boost::shared_ptr\u0026lt;socket_t\u0026gt; socket_spt;\n\nvoid coroutine_accept(acceptor_t\u0026amp; acceptor,boost::asio::yield_context ctx);\nvoid coroutine_read(socket_spt sp,boost::asio::yield_context ctx);\n\nint main()\n{\n    try\n    {\n        //asio 服務\n        io_service_t service;\n\n        //接收器\n        acceptor_t acceptor(service,boost::asio::ip::tcp::endpoint(boost::asio::ip::address::from_string(LISTEN_ADDRESS),LISTEN_PORT));\n\n        std::cout\u0026lt;\u0026lt;\"work at \"\u0026lt;\u0026lt;LISTEN_ADDRESS\u0026lt;\u0026lt;\":\"\u0026lt;\u0026lt;LISTEN_PORT\u0026lt;\u0026lt;std::endl;\n\n        std::size_t n = boost::thread::hardware_concurrency();\n\n        for(std::size_t i=0; i\u0026lt;n; ++i)\n        {\n            //啓動 接收連接 coroutine\n            boost::asio::spawn(service,boost::bind(coroutine_accept,boost::ref(acceptor),_1));\n        }\n\n        boost::thread_group threads;\n        for(std::size_t i=0; i\u0026lt;n; ++i)\n        {\n            threads.create_thread([\u0026amp;service]()\n            {\n                //運行asio服務\n                service.run();\n            });\n        }\n        threads.join_all();\n\n    }\n    catch(const boost::system::system_error\u0026amp; se)\n    {\n        std::cout\u0026lt;\u0026lt;se.what()\u0026lt;\u0026lt;\"\\n\";\n    }\n    return 0;\n}\nvoid coroutine_accept(acceptor_t\u0026amp; acceptor,boost::asio::yield_context ctx)\n{\n    while(true)\n    {\n        boost::system::error_code ec;\n        io_service_t\u0026amp; service = acceptor.get_io_service();\n        try\n        {\n            socket_spt sp = boost::make_shared\u0026lt;socket_t\u0026gt;(service);\n            acceptor.async_accept(*sp,ctx[ec]);\n            acceptor.get_io_service();\n            if(ec)\n            {\n                //錯誤\n                std::cout\u0026lt;\u0026lt;ec\u0026lt;\u0026lt;\"\\n\";\n            }\n            else\n            {\n                //爲 socket 啓動 通信 coroutine\n                boost::asio::spawn(service,boost::bind(coroutine_read,sp,_1));\n            }\n\n        }\n        catch(const std::bad_alloc\u0026amp; e)\n        {\n            std::cout\u0026lt;\u0026lt;e.what()\u0026lt;\u0026lt;\"\\n\";\n        }\n    }\n}\nvoid coroutine_read(socket_spt sp,boost::asio::yield_context ctx)\n{\n    boost::system::error_code ec;\n    socket_t\u0026amp; s = *sp;\n    try\n    {\n        //讀取消息\n        std::uint8_t buffer[BUFFER_SIZE];\n        std::size_t pos = 0;\n        while(pos \u0026lt; BUFFER_SIZE)\n        {\n            //接收消息 yield\n            std::size_t n = s.async_read_some(boost::asio::buffer(buffer + pos,BUFFER_SIZE - pos),ctx);\n            pos += n;\n            if(buffer[pos-1] == '\\n')\n            {\n                //echo\n                s.async_write_some(boost::asio::buffer(buffer,pos),ctx);\n                break;\n            }\n        }\n\n        //退出 關閉 socket\n    }\n    catch(const boost::system::system_error\u0026amp; se)\n    {\n        std::cout\u0026lt;\u0026lt;se.what()\u0026lt;\u0026lt;\"\\n\";\n    }\n\n    s.shutdown(socket_t::shutdown_both,ec);\n    s.close(ec);\n}\u003c/pre\u003e"