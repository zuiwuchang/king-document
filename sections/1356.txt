var __v="\u003cpre class=\"k-pre\"\u003evector\u0026lt;Elem\u0026gt; c 构造一个空 vector\nvector\u0026lt;Elem\u0026gt; c1(c2) 产生一个c2的副本\nvector\u0026lt;Elem\u0026gt; c(n) 用default构造函数产生一个大小为n的vector\nvector\u0026lt;Elem\u0026gt; c(n,elem) 产生一个大小为n的vector 每个元素值=elem\nvcetor\u0026lt;Elem\u0026gt; c(begin,end) 产生一个vector 初值为区间[begin,end)\nc.~vector\u0026lt;Elem\u0026gt;() 销毁所有元素 释放内存\n\nc.size()\nc.empty()\nc.max_size()\nc.capacity() 返回重新肥胖空间前可容纳元素最大值 \nc.reserve(n) 增大空间到可容纳n给元素 不能缩小\n==\n!=  !(=)\n\u0026lt;\n\u0026gt;\n\u0026lt;=  !(\u0026lt;)\n\u0026gt;=  !(\u0026gt;)\nc1=c2\nc.assign(n,elem) 将容器内容替换为n个elem\nc.assign(begin,end) ....[begin,end)\nc1.swap(c2)\nswap(c1,c2) //全局函数\n\nc.at(index) //或检查索引有效值\nc[index]\nc.front()\t//也不会检查元素是否存在 其他容器也是\nc.back()\t//同上\n\nc.begin()\nc.end()\nc.rbegin()\nc.rend()\n\nc.insert(pos,elem)\nc.insert(pos,n,elem)\nc.insert(pos,begin,end)\nc.push_back(elem)\nc.pop_back() //也不会检查元素是否存在 其他容器也是\nc.erase(pos)\nc.erase(begin,end)\nc.resize(n)  //将元素实力改为n 后面的删除 多出的元素以default构造\nc.resize(n,elem) //同上 多出元素是elem的副本\nc.clear()\n\u003c/pre\u003e"