var __v="\u003cpre class=\"k-pre\"\u003e//創建一個 WSAEVENT 失敗返回WSA_INVALID_EVENT (NULL) (以 人工重置 方式工作 初始化為 未激發)\n//如果需要自動重置 可以使用 CreateEvent \nWSAEVENT  WSACreateEvent (void);\n\n//關閉 WSAEVENT 句柄\nBOOL WSACloseEvent(\n  __in  WSAEVENT hEvent\n);\n\n//將 WSAEVENT 設置為未激發\nBOOL WSAResetEvent(\n  __in  WSAEVENT hEvent\n);\n\n//將 WSAEVENT 設置為激發態\nBOOL WSASetEvent(\n  __in  WSAEVENT hEvent\n);\n\n//將socket和WSAEVENT綁定 失敗返回 SOCKET_ERROR \nint WSAEventSelect(\n  __in  SOCKET s,\n  __in  WSAEVENT hEventObject,\n  __in  long lNetworkEvents\t\t//關心的網絡事件 FD_READ FD_WRITE FD_ACCEPT FD_CONNECT FD_CLOSE ...\n);\n\n//等待網絡事件\nDWORD WSAWaitForMultipleEvents(\n  __in  DWORD cEvents,\t\t\t\t//等待的WSAEVENT數組大小\n  __in  const WSAEVENT* lphEvents,\t\t//WSAEVENT數組地址\n  __in  BOOL fWaitAll,\t\t\t\t//TRUE 全部激發才返回\n  __in  DWORD dwTimeout,\t\t\t//等待超時 WSA_INFINITE 一直等待\n  __in  BOOL fAlertable\t\t\t\t//FALSE (當用於重疊i/o時才啟用)\n);\nWSAWaitForMultipleEvents返回值\nWSA_WAIT_FAILED\t函數失敗\n\n(WSA_WAIT_IO_COMPLETION fAlertable設置為TRUE時 用於重疊i/o)\n\nWSA_WAIT_TIMEOUT\n\nWSA_WAIT_EVENT_0 to (WSA_WAIT_EVENT_0 + cEvents - 1)\n\n返回值-WSA_WAIT_EVENT_0 為使WSAWaitForMultipleEvents返回的WSAEVENT在數組中的 索引\n\n//檢索發生的網絡事件\nint WSAEnumNetworkEvents(\t\n  __in   SOCKET s,\t\t\t\t\t\t\t\t//應該是發生網絡事件的socket\n  __in   WSAEVENT hEventObject,\t\t\t\t\t//將此WSAEVENT 設置為未發態 (不需要傳入NULL)\n  __out  LPWSANETWORKEVENTS lpNetworkEvents\t\t//返回具體的網絡事件\n);\n\ntypedef struct _WSANETWORKEVENTS {  \nlong lNetworkEvents;  \t\t\t\t//FD_READ FD_WRITE ...等事件安位 \u0026\nint iErrorCode[FD_MAX_EVENTS];\t\t//FD_READ_BIT FD_WRITE_BIT ...等事件錯誤碼(既是否發生錯誤) 0為發生錯誤\n} WSANETWORKEVENTS,  *LPWSANETWORKEVENTS;\n\u003c/pre\u003e"