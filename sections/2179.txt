var __v="\u003cpre class=\"k-pre\"\u003e#include \u0026lt;boost/asio.hpp\u0026gt;\n\nasio 庫是boost 提供了跨平台的 網絡通信功能  支持 TCP UDP ICMP 等協議\nasio不需要編譯 然其依賴的 其他庫 需要編譯 如 boost::system boost::datatime ... 若需要支持SSL還要安裝 OpenSSL\n\nasio使用 前攝模式(Proactor) 封裝了操作系統的 select poll/epoll kqueue overlapped I/O 等機制 實現了異步I/O\nio_service 是asio的核心類 任何一個 操作 都需要 io_service\n\n同步模式下:\n\t程序發起一個I/O請求(向 io_service提交請求)\n\tio_service把操作交給 os 並同步等待\n\t當io完成 os通知io_service\t\n\tio_service 把結果 返回給程序\n\n異步模式下:\n\t程序發起一個io請求 並定義一個用於回調的 完成處理函數  \n\tio_service 把操作交給os 並立刻返回(調用io_service的run函數 可等待操作完成)\n\t當io完成 io_service獲取結果 並調用 完成處理函數\n    \n\nasio不使用 os提供的線程 而是定義了一個 自己的 線程概念 strand\nstrand 保證 在多線程環境下 代碼可以正確執行 而無需使用互斥量\nio_service::strand::wap 函數可以包裝一個函數在 strand中執行\n\nasio使用 mutable_buffer const_buffer 來封裝緩衝區 其可以被安全的應用在異步讀寫中 使用buffer()函數 能夠包裝常用的c++容器 array vector string...\nread() write() 用於 讀寫緩衝區\n\nasio 使用 system庫的 error_code system_error 表示程序運行的 錯誤 \n基本上 所有操作都有兩種 重載形式 \n\t一種是有個 error_code的輸出參數 調用函數後 必須檢查此參數 以驗證是否發生錯誤\n\t一種是 沒有此參數 出錯時 拋出 system_error 異常 \n\u003c/pre\u003e"