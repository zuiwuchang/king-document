var __v="\u003cpre class=\"k-pre\"\u003e使用Save可以把 數據保存到 IStream中 之後可用IStream數據 轉到 char* 用於網絡存儲 或 寫入文件\n\u003c/pre\u003e\n\n\u003cpre class='prettyprint linenums'\u003e//COM 接口\nIStorage* pIStorage\t=\tNULL;\nIStream* pIStream\t=\tNULL;\n\ntry\n{\n\tGdiplus::Image image(L\"test.jpg\");\n\n\t//創建一個複合文檔的 OLE 接口\n\tHRESULT hr;\n\thr\t=\tStgCreateDocfile(NULL\n\t\t,STGM_READWRITE|STGM_CREATE|STGM_SHARE_EXCLUSIVE\n\t\t,0\n\t\t,\u0026amp;pIStorage\n\t\t);\n\tif(FAILED(hr))\n\t{\n\t\tthrow 1;\n\t}\n\n\t//為OLE創建 一個IStream接口\n\thr = pIStorage-\u0026gt;CreateStream(L\"StreamImage\"\n\t\t ,STGM_READWRITE|STGM_SHARE_EXCLUSIVE\n\t\t ,0\n\t\t ,0\n\t\t ,\u0026amp;pIStream);\n\tif(FAILED(hr))\n\t{\n\t\tthrow 1;\n\t}\n\n\t//將Image 保存到IStream\n\tCLSID png_clsid;\n\tif(!dark::gdiplus::tools::get_encoder_clsid(L\"image/png\",png_clsid))\n\t{\n\t\tthrow 1;\n\t}\n\timage.Save(pIStream,\u0026amp;png_clsid);\n\n\t//返回 IStream 數據 大小\n\tSTATSTG myStreamStats;\n\tpIStream-\u0026gt;Stat(\u0026amp;myStreamStats,0);\n\tULONG size\t=\t(ULONG)myStreamStats.cbSize.QuadPart,dw;\n\t\n\t//分配動態內存\n\tboost::scoped_array\u0026lt;char\u0026gt; buffer(new char[size]);\n\t//移動到IStream起始位置\n\tpIStream-\u0026gt;Seek(LARGE_INTEGER(),STREAM_SEEK_SET,0);\n\t//讀取IStream到動態內存\n\tpIStream-\u0026gt;Read(buffer.get(),size,\u0026amp;dw);\n\t\n\t//保存到文件\n\tstd::ofstream outf(\"test.png\",std::ios::binary | std::ios::trunc | std::ios::out);\n\toutf.write(buffer.get(),size);\n\toutf.close();\n}\ncatch(const int)\n{\n}\n\n//釋放COM接口\nif(pIStream)\n{\n\tpIStream-\u0026gt;Release();\n}\nif(pIStorage)\n{\n\tpIStorage-\u0026gt;Release();\n}\u003c/pre\u003e"