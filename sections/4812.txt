var __v="\u003cpre class='k-pre'\u003e如果 在 Wait 前 Signal/Broadcast 則 之後都無法使用 Wait\n如果 需要多次 重用Wait過程 一個做法是 在 Signal/Broadcast 前 判斷 是否有 Wait存在\u003c/pre\u003e\n\u003cpre class='prettyprint linenums'\u003epackage main\n\nimport (\n\t\"log\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tcond := sync.NewCond(\u0026amp;sync.Mutex{})\n\n\t// 定義 工作 數量\n\twork := 0\n\t// 定義 存儲正在 wait 的 數量\n\twait := 0\n\n\tgo func() {\n\n\t\tfor i := 0; i \u0026lt; 5; i++ {\n\t\t\ttime.Sleep(time.Millisecond)\n\t\t\tcond.L.Lock()\n\t\t\t//增加 工作\n\t\t\tlog.Println(\"add work\")\n\t\t\twork++\n\t\t\tif wait != 0 {\n\t\t\t\t//存在 等待 goroutine 喚醒 她\n\t\t\t\tlog.Println(\"signal work\")\n\t\t\t\tcond.Signal()\n\t\t\t}\n\t\t\tcond.L.Unlock()\n\t\t}\n\t\twg.Done()\n\t}()\n\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 2)\n\t\tfor i := 0; i \u0026lt; 5; i++ {\n\t\t\tcond.L.Lock()\n\t\t\tlog.Println(\"get work\")\n\t\t\tif work == 0 {\n\t\t\t\t// 沒有 工作 等待\n\t\t\t\twait++\n\t\t\t\tlog.Println(\"wait work\")\n\t\t\t\tcond.Wait()\n\n\t\t\t\t// 減少 等待 計數\n\t\t\t\twait--\n\t\t\t}\n\t\t\t// 處理工作\n\t\t\tlog.Println(\"do work\")\n\t\t\twork--\n\t\t\tcond.L.Unlock()\n\t\t}\n\n\t\twg.Done()\n\t}()\n\n\twg.Wait()\n\tlog.Println(\"end\")\n}\n\u003c/pre\u003e"