var __v="\u003cpre class=\"k-pre\"\u003e//創建一個 WSAEVENT 失敗返回WSA_INVALID_EVENT (NULL) (以 人工重置 方式工作 初始化為 未激發)\n//如果需要自動重置 可以使用 CreateEvent \nWSAEVENT  WSACreateEvent (void);\n\n//重疊結構\ntypedef struct _WSAOVERLAPPED {\n  DWORD  Internal; \t\t\t\t\t//保存i/o請求錯誤碼\n  DWORD  InternalHigh; \t\t\t\t\t/異步操作完成時保存設計傳輸字節\n  DWORD  Offset; \t\t\t\t\t//文件操作偏移低32位 非文件應該為0 否則可能導致io失敗\n  DWORD  OffsetHigh; \t\t\t\t\t//...高\n  WSAEVENT  hEvent;\t\t\t\t\t//事件對象句柄\n} WSAOVERLAPPED, FAR * LPWSAOVERLAPPED;        \n\n//等待重疊IO完成事件 (返回值 WSA_WAIT_IO_COMPLETION 只有fAlertable為TRUE 時才有可能)\nDWORD WSAWaitForMultipleEvents(\n  __in  DWORD cEvents,\t\t\t\t//等待的WSAEVENT數組大小\n  __in  const WSAEVENT* lphEvents,\t\t//WSAEVENT數組地址\n  __in  BOOL fWaitAll,\t\t\t\t//TRUE 全部激發才返回\n  __in  DWORD dwTimeout,\t\t\t//等待超時 WSA_INFINITE 一直等待\n  __in  BOOL fAlertable\t\t\t\t//FALSE (當用於完成例程時才啟用TRUE)\n);\n\n//當io完成時 獲取重疊操作是否成功  （如果socket關閉 如網絡異常斷開連接 返回FALSE）\nBOOL WSPGetOverlappedResult(\n  __in   SOCKET s,\t\t\t\t//要查詢的 socket\n  __in   LPWSAOVERLAPPED lpOverlapped,\t\t//餘socket關聯的 WSAOVERLAPPED\n  __out  LPDWORD lpcbTransfer,\t\t\t//返回重疊操作實際操作字節數 如WSASend 發送了多少數據\n  __in   BOOL fWait,\t\t\t\t//(設置為TRUE io完成 此返回才返回) (FALSE IO正在操作函數依然返回)\n  __out  LPDWORD lpdwFlags,\t\t\t//返回標誌 對於WSARecv(==0 客戶機斷開) WSASend 為實際傳輸字節 \n  __out  LPINT lpErrno\t\t\t\t//返回一個錯誤碼 不能為NULL\n);\n\n\nWSA...\n//創建一個支持重疊的socket\nSOCKET WSASocket(\n  __in  int af,\t\t\t\t\t//同socket函數\n  __in  int type,\t\t\t\t//同socket函數\n  __in  int protocol,\t\t\t\t//同socket函數\n  __in  LPWSAPROTOCOL_INFO lpProtocolInfo,\t//通常NULL\n  __in  GROUP g,\t\t\t\t\t\t\t//系統保留 0\n  __in  DWORD dwFlags\t\t\t\t//WSA_FLAG_OVERLAPPED 代表使用重疊io\n);\n\n//接收一個socket連接  ERROR_IO_PENDING == WSAGetLastError （）\nBOOL AcceptEx(\n  __in   SOCKET sListenSocket,\t\t\t/監聽socket\n  __in   SOCKET sAcceptSocket,\t\t\t//接受連接的套接字 需要自己創建\n  __in   PVOID lpOutputBuffer,\t\t\t//緩衝區 用於三種數據接收 新建連接發送的第一個數據塊  服務器本地地址 客戶機地址 \n  __in   DWORD dwReceiveDataLength,\t\t//緩衝區 保留多大數據用於接收 數據塊 為0 AcceptEx不會數據塊\n  __in   DWORD dwLocalAddressLength,\t\t//緩衝區 ... 服務器本地地址 ...\n  __in   DWORD dwRemoteAddressLength,\t\t//緩衝區 ... 客戶機地址 ...\n  __out  LPDWORD lpdwBytesReceived,\t\t//返回實際操作字節數同步操作下此值才會被設置\n  __in   LPOVERLAPPED lpOverlapped\t\t//WSAOVERLAPPED結構\n);\n返回ip\nvoid GetAcceptExSockaddrs(\n  __in   PVOID lpOutputBuffer,\t\t\t//AcceptEx 傳入的緩衝區\n  __in   DWORD dwReceiveDataLength,\t\t//AcceptEx 傳入 數據塊 大小\n  __in   DWORD dwLocalAddressLength,\t//AcceptEx 傳入 本地地址 大小\n  __in   DWORD dwRemoteAddressLength,\t//AcceptEx 傳入 遠程地址 大小\n  __out  LPSOCKADDR* LocalSockaddr,\t\t//不能為NULL 返回 本地地址\n  __out  LPINT LocalSockaddrLength,\t\t//...\t\t返回地址大小\n  __out  LPSOCKADDR* RemoteSockaddr,\t//...\t\t遠程\n  __out  LPINT RemoteSockaddrLength\t\t//...\n);\n\tSOCKADDR_IN*\tlocal;\n\tSOCKADDR_IN*\tremote;\n\tint\tlocal_len,remote_len;\n\n\tGetAcceptExSockaddrs(overlappedex.buffer.get(),0,0,overlappedex.size_buffe\n\t\t,(sockaddr**)\u0026amp;local,\u0026amp;local_len,(sockaddr**)\u0026amp;remote,\u0026amp;remote_len);\n\n\tchar* lp=inet_ntoa(remote-\u0026gt;sin_addr);\n\n//接受數據 成功返回0\tWSA_IO_PENDING\t==\tWSAGetLastError()\nint WSARecv(\n  __in     SOCKET s,\n  __inout  LPWSABUF lpBuffers,\t\t\t\t// 指向WSABUF的數組 用於存儲數據\n  __in     DWORD dwBufferCount,\t\t\t\t//WSABUF數組大小\n  __out    LPDWORD lpNumberOfBytesRecvd,\t\t//返回傳輸字節數(不能為NULL)\n  __inout  LPDWORD lpFlags,\t\t\t\t\t\t//（通常DWORD flags=0）\n  __in     LPWSAOVERLAPPED lpOverlapped,\t\t//WSAOVERLAPPED結構\n  __in     LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine\t//NULL (用於完成例程時使用)\n);\ntypedef struct _WSABUF {\n  u_long  len; \t\t\t//緩衝區大小\n  char FAR  *buf; \t\t//緩衝區\n} WSABUF, FAR * LPWSABUF;\n\n//發送數據 參數同 WSARecv\nint WSASend(\n  __in   SOCKET s,\n  __in   LPWSABUF lpBuffers,\n  __in   DWORD dwBufferCount,\n  __out  LPDWORD lpNumberOfBytesSent,\n  __in   DWORD dwFlags,\n  __in   LPWSAOVERLAPPED lpOverlapped,\n  __in   LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine\n);\n\ndwLocalAddressLength dwRemoteAddressLength的大小應該比 當前協議允許的最大地址 長度大16字節\n如 tcp 協議 大小為 sizeof(SOCKADDRIN)+16\n\u003c/pre\u003e"