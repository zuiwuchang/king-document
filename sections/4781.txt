var __v="\u003cpre class='k-pre'\u003e\u003cstrong\u003eStop\u003c/strong\u003e\n對於 NewTimer 調用 Stop 如果 返回 true 則 定時器已經被停止\n如果 為 false 則 定時器 已經過期 或者 已經被關閉\n如果 定義是 過期 為了 防止 執行 \u003cstrong\u003et.C\u0026lt;-\u003c/strong\u003e 的 goroutine 無法結束 你應該 執行 \u003cstrong\u003e\u0026lt;-t.C\u003c/strong\u003e\n \u003c/pre\u003e\n\u003cpre class='prettyprint linenums'\u003epackage main\n\nimport (\n\t\"log\"\n\t\"time\"\n)\n\nfunc main() {\n\tlog.SetFlags(log.LstdFlags | log.Lshortfile)\n\tlog.Println(\"***\tExample 1\t***\")\n\tt := time.NewTimer(time.Second)\n\tlog.Println(t.Stop()) // true\n\tlog.Println(t.Stop()) // fasle\n\tlog.Println(\"定時器 被 正確 關閉 不想要 執行 t.C\u0026lt;-\")\n\n\tlog.Println(\"***\tExample 2\t***\")\n\tt = time.NewTimer(time.Second)\n\tif !t.Stop() {\n\t\t// 不會執行 定時器 正常 關閉\n\t\tlog.Println(\"防止 t.C\u0026lt;- 掛起 Stop 會使 t.C\u0026lt;- 立刻執行\")\n\t\t\u0026lt;-t.C\n\t}\n\tif !t.Stop() {\n\t\tlog.Println(\"定時器 正常 關閉 不要執行 \u0026lt;-t.C\")\n\t}\n\n\tlog.Println(\"***\tExample 3\t***\")\n\tt = time.NewTimer(time.Millisecond)\n\ttime.Sleep(time.Second)\n\tif !t.Stop() {\n\t\tlog.Println(\"防止 t.C\u0026lt;- 掛起 Stop 會使 t.C\u0026lt;- 立刻執行\")\n\t\t\u0026lt;-t.C\n\t}\n\tif !t.Stop() {\n\t\tlog.Println(\"已經執行過 t.C\u0026lt;- 不要多次執行 \u0026lt;-t.C\")\n\t}\n\n\tlog.Println(\"***\tExample 4\t***\")\n\tt = time.NewTimer(time.Second)\n\t\u0026lt;-t.C\n\tif !t.Stop() {\n\t\tlog.Println(\"已經執行過 t.C\u0026lt;- 不要多次執行 \u0026lt;-t.C\")\n\t}\n}\n\u003c/pre\u003e\n\n\u003cpre class='k-pre'\u003e\u003cstrong\u003eReset\u003c/strong\u003e\nReset 可以重置定時器 在 指定時間後 觸發 \n然 調用者 需要 避免 新的 觸發 和原 觸發 不會 同時 競爭 \u003cstrong\u003et.C\u003c/strong\u003e\n故 調用者 在調用 Reset前 需要依據 自己的代碼 正確的 調用 Stop \n\u003c/pre\u003e"