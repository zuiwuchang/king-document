var __v="\u003cpre class='k-pre'\u003e只要 實現 TransportCredentials 接口 即可 實現自定義的 傳輸通道 驗證\nTransportCredentials 會在第一次建立 tcp 時 進行 驗證\n\n\u003c/pre\u003e\n\u003cpre class='prettyprint linenums'\u003etype TransportCredentials interface {\n\t// 客戶端 使用 此函數 向 服務器 進行 身份 認證\n\t//\n\t// 實現 應該 依據 context.Context 的上下問 進行 超時處理 以及 撤銷操作\n\t//\n\t// 如果 返回暫時性 錯誤 gRPC 會 嘗試 重新連接\n\t// (io.EOF, context.DeadlineExceeded or err.Temporary() == true).\n\t// 如果錯誤是臨時 應該 實現 Temporary() bool 因為 會進行 err.Temporary() == true 測試 如果不實現則認為不是臨時錯誤\n\n\t// 如果 返回 net.Conn 是 closed 則 實現應該 close 傳入的 net.Conn\n\tClientHandshake(context.Context, string, net.Conn) (net.Conn, AuthInfo, error)\n\t//此函數 用於 服務器 對 客戶端的 認證處理\n\t//\n\t// 如果 返回 net.Conn 是 closed 則 實現應該 close 傳入的 net.Conn\n\tServerHandshake(net.Conn) (net.Conn, AuthInfo, error)\n\t//此函數 用於 為人類 返回 協議的 一些文字描述\n\tInfo() ProtocolInfo\n\t//此函數 用戶 創建一個 副本\n\tClone() TransportCredentials\n\t//此函數 用於 覆蓋 證書 標明的 服務器 主機名稱\n\tOverrideServerName(string) error\n}\u003c/pre\u003e"