var __v="\u003ctable class=\"table\"\u003e\n\u003ctr\u003e\u003cth\u003e成员函数\u003c/th\u003e\u003cth\u003e读取，直到...\u003c/th\u003e\u003cth\u003e字符数\u003c/th\u003e\u003cth\u003e添加结束符\u003c/th\u003e\u003cth\u003e返回值\u003c/th\u003e\u003c/tr\u003e\n\u003ctr\u003e\u003ctd\u003eget()\u003c/td\u003e\u003ctd\u003e读入下一个字符\u003c/td\u003e\u003ctd\u003e1\u003c/td\u003e\u003ctd\u003e否\u003c/td\u003e\u003ctd\u003e读入的字符或常量EOF\u003c/td\u003e\u003c/tr\u003e\n\u003ctr\u003e\u003ctd\u003eget(s,num)\u003c/td\u003e\u003ctd\u003eeof或new line(结果不包含'\\n')\u003c/td\u003e\u003ctd\u003e最多num-1\u003c/td\u003e\u003ctd\u003e是\u003c/td\u003e\u003ctd\u003eistream\u003c/td\u003e\u003c/tr\u003e\n\u003ctr\u003e\u003ctd\u003eget(s,num,t)\u003c/td\u003e\u003ctd\u003eeof或new line 或t(结果不包含'\\n'和t)\u003c/td\u003e\u003ctd\u003e最多num-1\u003c/td\u003e\u003ctd\u003e是\u003c/td\u003e\u003ctd\u003eistream\u003c/td\u003e\u003c/tr\u003e\n\u003ctr\u003e\u003ctd\u003egetline(s,num)\u003c/td\u003e\u003ctd\u003eeof或new line(结果包含'\\n')\u003c/td\u003e\u003ctd\u003e最多num-1\u003c/td\u003e\u003ctd\u003e是\u003c/td\u003e\u003ctd\u003eistream\u003c/td\u003e\u003c/tr\u003e\n\u003ctr\u003e\u003ctd\u003egetline(s,num,t)\u003c/td\u003e\u003ctd\u003eeof或new line 或t(结果包含'\\n'和t)\u003c/td\u003e\u003ctd\u003e最多num-1\u003c/td\u003e\u003ctd\u003e是\u003c/td\u003e\u003ctd\u003eistream\u003c/td\u003e\u003c/tr\u003e\n\u003ctr\u003e\u003ctd\u003eread(s,num)\u003c/td\u003e\u003ctd\u003eeof(遇到end-of-file出错并设置相应 stream状态)\u003c/td\u003e\u003ctd\u003e最多num\u003c/td\u003e\u003ctd\u003e否\u003c/td\u003e\u003ctd\u003eistream\u003c/td\u003e\u003c/tr\u003e\n\u003ctr\u003e\u003ctd\u003ereadsome(s,num)\u003c/td\u003e\u003ctd\u003eeof(遇到end-of-file不会出错且不会设置 stream状态)\u003c/td\u003e\u003ctd\u003e最多num\u003c/td\u003e\u003ctd\u003e否\u003c/td\u003e\u003ctd\u003ecount\u003c/td\u003e\u003c/tr\u003e\n\u003c/table\u003e\n\u003cpre class=\"k-pre\"\u003estd::streamsize gcount();//返回上次 非格式 读取的字符数\n\n\n\nistream\u0026amp; istream::ignore();//适用于\u0026gt;\u0026gt;和无格式读取 下次读取忽略第一个1个字符\nistream\u0026amp; istream::ignore(streamsize count);//...n个字符\nistream\u0026amp; istream::ignore(streamsize count,int delin);//...n个字符或直到舍弃delin字符\n若count==std::numeric_limits\u0026lt;std::streamsize\u0026gt;::max()将舍弃全部或delin前段所有字符\n\n\n\nint istream::peek();//返回下次将要读取的字符 但不把它读出来 下次还是读取它\n\n\nistream\u0026amp; istream::unget();\nistream\u0026amp; istream::putback(char c);\n//把上次读取的字符放回stream使之可在下次被读出putback会检查c是否是上次的字符\n\u003c/pre\u003e"