var __v="\u003cpre class=\"k-pre\"\u003e//構造\ntemplate\u0026lt;typename T0,....T9\u0026gt;\ntuple()\n...\ntuple(T0,...T9)\n\n//返回第n個元素\ntemplate \u0026lt;N\u0026gt;\nT\u0026amp; get();\n\n//tuple 支持全面比較(字典順序) 但要求其保存的型別支持比較 其實際只是 調用相應型別自己的比較函數\n#include\u0026lt;boost\\tuple\\tuple_comparison.hpp\u0026gt;\n\u0026lt;\n\u0026gt;\n==\n!=\n...\n\n//tuple 支持io流操作 但要求 其內部型別支持\n//tuple默認 以 ( 開始 空格分隔元素 ) 結束\n#include \u0026lt;boost/tuple/tuple_io.hpp\u0026gt;\n//boost提供了 一下三個 格式操作符 用於改變 開始 分隔 結束 符號\nboost::tuples::set_open(const CharType c)\nboost::tuples::set_delimiter(const CharType c)\nboost::tuples::set_close(const CharType c)\n\n//連接變量\nboost::tie 用法類似 make_tuple 然其 產生的將是 \u0026amp; 型的 tuple\nboost::tie 可用於左值以連接變量 以可用於連接 std::pair\nboost::tuples::ignore 可在連接時 作為佔位符 以忽略不需要的 元素\n\n//內部結構\ntuple 內部使用 boost::tuples::cons 保存元素 其為一個鍊錶 \nget_head() 返回保存的元素\nget_tail() 返回下一個 cons 節點 尾節點指向 空類null_type\n故可依次遞歸 tuple\n\n//輔助類 T 為一個 tuple\nboost::tuples::element\u0026lt;N,T\u0026gt;::type 返回T中第Nge元素型別\nboost::tuples::length\u0026lt;T\u0026gt;::value 返回T的元素數量\n\u003c/pre\u003e"