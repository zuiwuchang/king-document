var __v="\n\u003cpre class='prettyprint linenums'\u003e// 用 函數 包裝 組播 共享 作用域\nfunction multicastSubscriber() {\n  // 創建 共享 數據\n  let i = 0;\n  let timer;\n  // 保存 組播的 訂閱者\n  let subscribers = []\n\n  // 返回 構造 Observable 需要的函數\n  return (subscriber) =\u0026gt; {\n    // 增加 訂閱者\n    subscribers.push(subscriber);\n    if (!timer) {\n      timer = setInterval(() =\u0026gt; {\n        // 組播 next\n        subscribers.forEach((subscriber) =\u0026gt; {\n          subscriber.next(i);\n        })\n\n        i++;\n        if (i == 5) {\n          clearInterval(timer);\n          timer = null;\n          // 組播 complete\n          subscribers.forEach((subscriber) =\u0026gt; {\n            subscriber.complete();\n          })\n        }\n      }, 500);\n    }\n    return {\n      unsubscribe() {\n        // 移除 訂閱者\n        subscribers.splice(subscribers.indexOf(subscriber), 1);\n\n        // 訂閱者 為空 停止 消息 發佈\n        if (subscribers.length == 0) {\n          clearInterval(timer);\n          timer = null;\n        }\n      },\n    }\n  }\n}\n\n// 創建 可觀察對象 Observable\nconst observable = new Observable(multicastSubscriber());\n\n// 第一個 訂閱\nobservable.subscribe(\n  (v) =\u0026gt; {\n    console.log('subscribe-0 val = ', v);\n  },\n);\n// 第二個 訂閱\nsetTimeout(() =\u0026gt; {\n  observable.subscribe(\n    (v) =\u0026gt; {\n      console.log('subscribe-1 val = ', v);\n    },\n  );\n}, 1000);\u003c/pre\u003e"