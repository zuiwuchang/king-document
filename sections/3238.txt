var __v="\n\u003cpre class='prettyprint linenums'\u003epDriverObject-\u0026gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlDispatchRoutine;\n         \n         #pragma PAGE_MEMORY\nNTSTATUS ControlDispatchRoutine(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp)\n{\n\tKdPrint((\"ControlDispatchRoutine begin\\n\"));\n\t\n\tNTSTATUS status = STATUS_NOT_SUPPORTED;\n\tpIrp-\u0026gt;IoStatus.Information=0; //设置返回的实际操作字节数 无实意(既程序员自定)\n\n\t//从irp堆栈结构中 获取设备对象的 irp 结构\n\tPIO_STACK_LOCATION lpIoStack=IoGetCurrentIrpStackLocation(pIrp);\n\n\t//如果成功获取到 irp 结构\n\tif(lpIoStack)\n\t{\n\t\t//判断控制码\n\t\tswitch(lpIoStack-\u0026gt;Parameters.DeviceIoControl.IoControlCode)\n\t\t{\n\t\tcase IOCTL_DIRECT_IN://写如到驱动\n\n\t\t\tKdPrint((\"case IOCTL_DIRECT_IN\\n\"));\n\t\t\tstatus=WriteDirectIn(pIrp,lpIoStack-\u0026gt;Parameters.DeviceIoControl.InputBufferLength,lpIoStack-\u0026gt;Parameters.DeviceIoControl.OutputBufferLength);\n\t\t\tbreak;\n\t\tcase IOCTL_DIRECT_OUT://从驱动读数据到用户层\n\t\t\tstatus=ReadDirectOut(pIrp,lpIoStack-\u0026gt;Parameters.DeviceIoControl.InputBufferLength,lpIoStack-\u0026gt;Parameters.DeviceIoControl.OutputBufferLength);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\t//设置pIrp状态 否则驱动无法继续进行其他工作\n\tpIrp-\u0026gt;IoStatus.Status=STATUS_SUCCESS;//返回成功\n\tIoCompleteRequest( pIrp, IO_NO_INCREMENT );\n\tKdPrint((\"ControlDispatchRoutine end\\n\"));\n\treturn status;\n}\n\n\n#pragma PAGE_MEMORY\nNTSTATUS WriteDirectIn(IN PIRP pIrp,ULONG inSize,ULONG outSize)\n{\n\tKdPrint((\"WriteDirectIn begin\\n\"));\n\tNTSTATUS status = STATUS_SUCCESS;\n\n\t//获取用户层传入的 输入缓冲区内容拷贝 的地址\n\tPVOID lp_input_buffer=pIrp-\u0026gt;AssociatedIrp.SystemBuffer,\n\t\tlp_output_buffer=NULL;\n\n\t//如果传入了输出缓冲区\n\tif(pIrp-\u0026gt;MdlAddress)\n\t{\n\t\t//锁定输出缓冲区 并映射到内核以供 驱动使用\n\t\tlp_output_buffer=MmGetSystemAddressForMdlSafe(pIrp-\u0026gt;MdlAddress,NormalPagePriority );\n\t}\n\n\tKdPrint((\"WriteDirectIn inSize=%d outSize=%d %S\\n\",inSize,outSize,lp_input_buffer));\n\t\n\tUNICODE_STRING unicode_string;\n\tRtlInitUnicodeString(\u0026amp;unicode_string,L\"写入数据成功\");\n\tRtlCopyMemory(lp_output_buffer,unicode_string.Buffer,unicode_string.Length);\n\t\n\t\n\tpIrp-\u0026gt;IoStatus.Information=unicode_string.Length;\n\n\tKdPrint((\"WriteDirectIn end%d\\n\"));\n\n\treturn status;\n}\n\n\n#pragma PAGE_MEMORY\nNTSTATUS ReadDirectOut(IN PIRP pIrp,ULONG inSize,ULONG outSize)\n{\n\tKdPrint((\"ReadDirectOut begin\\n\"));\n\tNTSTATUS status = STATUS_SUCCESS;\n\n\t\n\tPVOID lp_output_buffer=NULL;\n\n\t//如果传入了输出缓冲区\n\tif(pIrp-\u0026gt;MdlAddress)\n\t{\n\t\t//锁定输出缓冲区 并映射到内核以供 驱动使用\n\t\tlp_output_buffer=MmGetSystemAddressForMdlSafe(pIrp-\u0026gt;MdlAddress,NormalPagePriority );\n\t}\n\n\tKdPrint((\"ReadDirectOut inSize=%d outSize=%d\\n\",inSize,outSize));\n\t\n\tUNICODE_STRING unicode_string;\n\tRtlInitUnicodeString(\u0026amp;unicode_string,L\"读取数据成功\");\n\tRtlCopyMemory(lp_output_buffer,unicode_string.Buffer,unicode_string.Length);\n\t\n\tpIrp-\u0026gt;IoStatus.Information=unicode_string.Length;\n\n\tKdPrint((\"ReadDirectOut end%d\\n\"));\n\n\treturn status;\n}\u003c/pre\u003e"