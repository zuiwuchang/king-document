var __v="\n\u003cpre class='prettyprint linenums'\u003epackage main\n \nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"math/rand\"\n\t\"time\"\n)\n \n//定義一個 樹 結構\ntype Element struct {\n\tK int\n \n\t//顏色定義\n\tRed bool\n \n\t//父節點\n\tP *Element\n \n\t//子節點\n\tL, R *Element\n}\n \n//定義葉節點\nvar ElementNil *Element = \u0026amp;Element{Red: false}\n \n//左旋轉\nfunc LeftRotate(root, x *Element) *Element {\n\t//緩存 y\n\ty := x.R\n \n\t//移動 β\n\tx.R = y.L\n\tif y.L != ElementNil {\n\t\ty.L.P = x\n\t}\n \n\t//y 佔據 原 x位置\n\ty.P = x.P\n\tif x.P == ElementNil { //更新root\n\t\troot = y\n\t} else if x == x.P.L {\n\t\tx.P.L = y\n\t} else {\n\t\tx.P.R = y\n\t}\n \n\t//x 成爲 y 孩子\n\ty.L = x\n\tx.P = y\n\treturn root\n}\n \n//右旋轉\nfunc RightRotate(root, y *Element) *Element {\n\t//緩存 x\n\tx := y.L\n \n\t//移動 β\n\ty.L = x.R\n\tif x.R != ElementNil {\n\t\tx.R.P = y\n\t}\n \n\t//x 佔據 原 y位置\n\tx.P = y.P\n\tif y.P == ElementNil { //更新root\n\t\troot = x\n\t} else if y == y.P.L {\n\t\ty.P.L = x\n\t} else {\n\t\ty.P.R = x\n\t}\n \n\t//y 成爲 x 孩子\n\tx.R = y\n\ty.P = x\n\treturn root\n}\n \n//插入 並返回新的 root 節點\nfunc Insert(root *Element, k int) *Element {\n\t//創建 新 節點\n\tz := \u0026amp;Element{K: k, Red: true, L: ElementNil, R: ElementNil}\n \n\t//記錄 z 的 父節點\n\ty := ElementNil\n\t//當前 位置\n\tx := root\n\tfor x != ElementNil {\n\t\tif x.K == k {\n\t\t\t//已經存在key 直接替換\n\t\t\t//x.V = v\n\t\t\treturn root\n\t\t}\n \n\t\ty = x\n\t\tif k \u0026lt; x.K {\n\t\t\t//比當前小 比對左子樹\n\t\t\tx = x.L\n\t\t} else {\n\t\t\t//比當前大 比對右子樹\n\t\t\tx = x.R\n\t\t}\n\t}\n \n\t//設置 父節點\n\tz.P = y\n\tif y == ElementNil { //設置新的 root\n\t\troot = z\n\t} else if k \u0026lt; y.K {\n\t\ty.L = z\n\t} else {\n\t\ty.R = z\n\t}\n\treturn InsertFixup(root, z)\n}\n \n//修復插入引起的 紅黑樹性質變化\nfunc InsertFixup(root, z *Element) *Element {\n\tfor z.P.Red {\n\t\tif z.P == z.P.P.L {\n\t\t\ty := z.P.P.R\n\t\t\t//case 1\n\t\t\tif y.Red {\n\t\t\t\tz.P.Red = false\n\t\t\t\ty.Red = false\n\t\t\t\tz.P.P.Red = true\n\t\t\t\tz = z.P.P\n\t\t\t\tcontinue\n\t\t\t}\n \n\t\t\t//case 2\n\t\t\tif z == z.P.R {\n \n\t\t\t\tz = z.P\n\t\t\t\troot = LeftRotate(root, z)\n\t\t\t}\n\t\t\t//case 3\n\t\t\tz.P.Red = false\n\t\t\tz.P.P.Red = true\n\t\t\troot = RightRotate(root, z.P.P)\n\t\t} else {\n\t\t\ty := z.P.P.L\n\t\t\t//case 1\n\t\t\tif y.Red {\n\t\t\t\tz.P.Red = false\n\t\t\t\ty.Red = false\n\t\t\t\tz.P.P.Red = true\n\t\t\t\tz = z.P.P\n \n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t//case 2\n\t\t\tif z == z.P.L {\n\t\t\t\tz = z.P\n\t\t\t\troot = RightRotate(root, z)\n\t\t\t}\n \n\t\t\t//case 3\n\t\t\tz.P.Red = false\n\t\t\tz.P.P.Red = true\n\t\t\troot = LeftRotate(root, z.P.P)\n\t\t}\n \n\t}\n\troot.Red = false\n\treturn root\n}\n \n//中順遍歷\nfunc InorderWalk(x *Element) {\n\tif x != nil {\n\t\tInorderWalk(x.L)\n\t\tif x != ElementNil {\n\t\t\tif x.Red { //驗證性質\n\t\t\t\tif x.P.Red || x.L.Red || x.P.Red {\n\t\t\t\t\tlog.Fatalln(\"bad rbt red\")\n\t\t\t\t}\n\t\t\t}\n \n\t\t\tif x.Red {\n\t\t\t\tfmt.Println(x.K, \"Red\")\n\t\t\t} else {\n\t\t\t\tfmt.Println(x.K, \"Black\")\n\t\t\t}\n\t\t}\n\t\tInorderWalk(x.R)\n\t}\n}\n \n//以子樹 v 替換 子樹 u 並返回新的 root\nfunc Transplant(root, u, v *Element) *Element {\n\tif u.P == ElementNil { //u爲root節點\n\t\troot = v\n\t} else if u == u.P.L { //u是 左孩子\n\t\tu.P.L = v\n\t} else /*if u==u.P.R*/ { //u是 右孩子\n\t\tu.P.R = v\n\t}\n \n\t//更新 v的 父節點\n\tv.P = u.P\n \n\treturn root\n}\n \n//返回 最小 節點\nfunc Min(x *Element) *Element {\n\tfor x != ElementNil \u0026amp;\u0026amp; x.L != ElementNil {\n\t\tx = x.L\n\t}\n\treturn x\n}\n \n//刪除指定節點 並返回新的 root\nfunc Erase(root, z *Element) *Element {\n\tif z == ElementNil {\n\t\treturn root\n\t}\n \n\tvar x *Element\n\ty := z\n\tred := y.Red\n\tif z.L == ElementNil {\n\t\tx = z.R\n\t\troot = Transplant(root, z, z.R)\n\t} else if z.R == ElementNil {\n\t\tx = z.L\n\t\troot = Transplant(root, z, z.L)\n\t} else {\n\t\ty = Min(z.R)\n\t\tred = y.Red\n\t\tx = y.R\n\t\tif y.P == z {\n\t\t\tx.P = y\n\t\t} else {\n\t\t\troot = Transplant(root, y, y.R)\n\t\t\ty.R = z.R\n\t\t\ty.R.P = y\n\t\t}\n\t\troot = Transplant(root, z, y)\n\t\ty.L = z.L\n\t\ty.L.P = y\n\t\ty.Red = z.Red\n\t}\n \n\tif !red {\n\t\troot = EraseFixup(root, x)\n\t}\n \n\treturn root\n}\nfunc EraseFixup(root, x *Element) *Element {\n\tif x == ElementNil {\n\t\treturn root\n\t}\n\tfor x != root \u0026amp;\u0026amp; !x.Red {\n\t\tif x == x.P.L {\n\t\t\tw := x.P.R\n\t\t\tif w.Red { //case 1\n\t\t\t\tw.Red = false\n\t\t\t\tx.P.Red = true\n\t\t\t\troot = LeftRotate(root, x.P)\n\t\t\t\tw = x.P.R\n \n\t\t\t}\n\t\t\tif !w.L.Red \u0026amp;\u0026amp; !w.R.Red { //case2\n\t\t\t\tw.Red = true\n\t\t\t\tx = x.P\n\t\t\t} else {\n\t\t\t\tif !w.R.Red {\n\t\t\t\t\tw.L.Red = false\n\t\t\t\t\tw.Red = true\n\t\t\t\t\troot = RightRotate(root, w)\n\t\t\t\t\tw = x.P.R\n\t\t\t\t}\n \n\t\t\t\tw.Red = x.P.Red\n\t\t\t\tx.P.Red = false\n\t\t\t\tw.R.Red = false\n\t\t\t\troot = LeftRotate(root, x.P)\n\t\t\t\tx = root\n\t\t\t}\n\t\t} else {\n \n\t\t\tw := x.P.L\n\t\t\tif w.Red { //case 1\n\t\t\t\tw.Red = false\n\t\t\t\tx.P.Red = true\n\t\t\t\troot = RightRotate(root, x.P)\n\t\t\t\tw = x.P.L\n \n\t\t\t}\n\t\t\tif !w.L.Red \u0026amp;\u0026amp; !w.R.Red { //case2\n\t\t\t\tw.Red = true\n\t\t\t\tx = x.P\n\t\t\t} else {\n\t\t\t\tif !w.L.Red {\n\t\t\t\t\tw.R.Red = false\n\t\t\t\t\tw.Red = true\n\t\t\t\t\troot = LeftRotate(root, w)\n\t\t\t\t\tw = x.P.L\n\t\t\t\t}\n \n\t\t\t\tw.Red = x.P.Red\n\t\t\t\tx.P.Red = false\n\t\t\t\tw.L.Red = false\n\t\t\t\troot = RightRotate(root, x.P)\n\t\t\t\tx = root\n\t\t\t}\n\t\t}\n\t}\n\tx.Red = false\n\treturn root\n}\n \n//查找 key 非遞歸\nfunc Search(x *Element, k int) *Element {\n\tfor x != ElementNil \u0026amp;\u0026amp; x.K != k {\n\t\tif k \u0026lt; x.K {\n\t\t\tx = x.L\n\t\t} else {\n\t\t\tx = x.R\n\t\t}\n\t}\n\treturn x\n}\nfunc main() {\n\trand.Seed(time.Now().Unix())\n\trand.Seed(1)\n \n\troot := Insert(ElementNil, 1)\n\tfor i := 0; i \u0026lt; 1000; i++ {\n\t\troot = Insert(root, rand.Int()%10000)\n\t\troot = Insert(root, i)\n\t}\n \n\tfor i := 0; i \u0026lt; 1000; i++ {\n\t\tz := Search(root, i)\n\t\tif z == nil {\n\t\t\tlog.Fatalln(\"bad search\")\n\t\t}\n\t\troot = Erase(root, z)\n\t}\n\tInorderWalk(root)\n}\u003c/pre\u003e"