var __v="\n\u003cpre class='prettyprint linenums'\u003e// test_scs.cpp : 定义控制台应用程序的入口点。\n//\n\n#include \"stdafx.h\"\n#define SERVER_NAME\tL\"kc-test\"\n\n#include \u0026lt;fstream\u0026gt;\nstd::ofstream _df(\"F:/project/c++/vs2010/test_scs/Debug/my.log\",std::ios::out|std::ios::trunc);\n#define K0_DEBUG_USE_DEBUG\n#define K0_DEBUG_COUT_FLUSH 1\n#define K0_DEBUG_SHOW_LINE 1\n#define K0_DEBUG_STREAM _df\n#include \u0026lt;k0/debug.hpp\u0026gt;\n\n//全局變量\nbool g_run = true;\nSERVICE_STATUS g_status;\nSERVICE_STATUS_HANDLE g_hServer;\n\n\nVOID WINAPI ServiceMain(\n  __in  DWORD dwArgc,\n  __in  LPTSTR* lpszArgv\n);\nVOID WINAPI ControlHandler(\n  __in  DWORD fdwControl\n);\nint _tmain(int argc, _TCHAR* argv[])\n{\n\t//定義待 註冊服務 數組\n\t//每個服務 會被運行在一個新啓的 線程中\n\tSERVICE_TABLE_ENTRY serviceTable[] = {\n\t\t{\n\t\t\tSERVER_NAME,\t//服務名\n\t\t\tServiceMain\t//服務 入口點函數\n\t\t},\n\t\t{NULL,NULL} // 以空數組 代表結束\n\t};\n\n\t\n\t\n\n\t//註冊服務 並等待服務停止\n\tK0_INFO(\"StartServiceCtrlDispatcher\")\n\tStartServiceCtrlDispatcher(serviceTable);\n\tK0_INFO(\"StartServiceCtrlDispatcher end\")\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n//傳入參數 通常都直接 忽略 \nVOID WINAPI ServiceMain(\n  __in  DWORD dwArgc,\n  __in  LPTSTR* lpszArgv\n)\n{\n\tK0_INFO(\"ServiceMain\")\n\t//註冊 ControlHandler\n\t//返回的 句柄 不需要關閉\n\tg_hServer = RegisterServiceCtrlHandler(SERVER_NAME,//服務名 必須和 SERVICE_TABLE_ENTRY中一致\n\t\tControlHandler\t//控制回調 在 StartServiceCtrlDispatcher 線程中被回調\n\t\t);\n\tif(!g_hServer)\n\t{\n\t\t//error\n\t\treturn;\n\t}\n\n\t//通知 scm 已經開始 繼續 初始化 服務\n\tg_status.dwServiceType = SERVICE_WIN32;\n\tg_status.dwCurrentState = SERVICE_START_PENDING;\t//設置當前服務 狀態\n\tg_status.dwControlsAccepted   = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;\t//設置允許的 ControlHandler\n\tg_status.dwWin32ExitCode = 0;\n\tg_status.dwServiceSpecificExitCode = 0;\n    g_status.dwCheckPoint   = 0;\n    g_status.dwWaitHint   = 0;\n\tSetServiceStatus(g_hServer,\u0026amp;g_status);\n\t\n\t//初始化 操作\n\t//...\n\n\t//通知 服務器 初始化 完成\n\tg_status.dwWaitHint = 0;\n\tg_status.dwCheckPoint = 0;\n\tg_status.dwCurrentState = SERVICE_RUNNING;\n    SetServiceStatus(g_hServer,\u0026amp;g_status);\n    \n\tK0_INFO(\"ServiceMain running\")\n\twhile(g_run)\n\t{\n\t\tSleep(1000);\n\t\tK0_INFO(\"ServiceMain loog\")\t\n\t}\n\tK0_INFO(\"ServiceMain end\")\n}\nVOID WINAPI ControlHandler(\n  __in  DWORD fdwControl\n)\n{\n\tK0_INFO(\"ControlHandler \"\u0026lt;\u0026lt;fdwControl)\n\tswitch(fdwControl)\n\t{\n\tcase SERVICE_CONTROL_STOP:\t//停止 服務\n\t\t//scm 要求 停止服務\n\t\tK0_INFO(\"do stop\")\n\t\t//通知 scm 已經 得到 停止通知\n\t\tfor(int i=0;i\u0026lt;12;++i)\n\t\t{\n\t\t\t\n\t\t\tg_status.dwWaitHint = 1000 * 35;\t//設置預計 完成 需要時間\n\t\t\tg_status.dwCheckPoint = i + 1;\t\t//更新 執行 進度\n\n\t\t\tg_status.dwCurrentState = SERVICE_STOP_PENDING;\t//設置當前服務 狀態\n\t\t\tK0_INFO(\"g_status.dwCheckPoint\"\u0026lt;\u0026lt;g_status.dwCheckPoint)\n\t\t\tSetServiceStatus(g_hServer,\u0026amp;g_status);\n\t\t\tSleep(1000 * 30);\n\t\t}\n\t\t\n\t\t//執行關閉操作\n\t\tg_run = false;\n\n\t\t//通知 scm 已經 停止服務\n\t\tg_status.dwWaitHint = 0;\n\t\tg_status.dwCheckPoint = 0;\n\t\tg_status.dwCurrentState = SERVICE_STOPPED;\t//設置當前服務 狀態\n\t\tSetServiceStatus(g_hServer,\u0026amp;g_status);\n\t\treturn;\n\tcase SERVICE_CONTROL_SHUTDOWN://os 關閉前 得到此通知 不會得到 SERVICE_CONTROL_STOP 通知\n\t\t//scm 要求 停止服務\n\t\tK0_INFO(\"do shutdowm\"\u0026lt;\u0026lt;g_status.dwWin32ExitCode)\n\t\tg_run = false;\n\n\t\t//同時 scm 已經 停止服務\n\t\tg_status.dwWaitHint = 0;\n\t\tg_status.dwCheckPoint = 0;\n\t\tg_status.dwCurrentState = SERVICE_STOPPED;\t//設置當前服務 狀態\n\t\tSetServiceStatus(g_hServer,\u0026amp;g_status);\n\t\treturn;\n\t}\n\n\tSetServiceStatus(g_hServer,\u0026amp;g_status);\n}\u003c/pre\u003e"