var __v="\u003cpre class=\"k-pre\"\u003e延迟提交不会立刻写入数据到剪贴板 而在有程序读取剪贴板或 本程序结束时才将数据写入剪贴板\n在SetClipboardData(CF_UNICODETEXT,hClip);时 传递 hClip=NULL以启动延迟提交;\n当剪贴板中的数据依然是本程序设置的NULL时(既没有其他程序再次向剪贴板写入数据)\n当程序退出时收到WM_RENDERALLFORMATS消息 当有程序读取剪贴板收到 WM_RENDERFORMAT \n(此时 WM_RENDERFORMAT写入数据不需要再调用OpenClipboard 和 EmptyClipboard WM_RENDERALLFORMATS却需要\n当设置数据后 再有程序读取剪贴板 不会收到WM_RENDERFORMAT 但当程序退出时依然会收到WM_RENDERALLFORMATS\n\u003c/pre\u003e\u003cpre class='prettyprint linenums'\u003e static bool IsSetClip=false; \nif(!IsSetClip \u0026amp;\u0026amp; WM_RENDERFORMAT==message  )\n{\n\tIsSetClip=true;\n\tCString wcs=L\"this is a test\";\n\t\tint len=(wcs.GetLength()+1)*sizeof(wchar_t);\n\t\t/*申请内存 并返回内存句柄(指向内存链表)  GlobalAlloc(GMEM_MOVEABLE,len) 申请内存 并返回内存句柄指向内存地址*/\n\t\tHANDLE hClip=GlobalAlloc(GMEM_MOVEABLE,len);\n\t\t/*根据指向内存链表的句柄获取内存地址*/\n\t\twchar_t * pBuf=(wchar_t *)GlobalLock(hClip);\n\t\twcscpy_s(pBuf,len/2,wcs.GetBuffer(0));\n\t\tGlobalUnlock(hClip);\n\t\t/*设置剪贴板*/\n\t\tSetClipboardData(CF_UNICODETEXT,hClip);\n}\nelse if(!IsSetClip \u0026amp;\u0026amp; WM_RENDERALLFORMATS==message)\n{\n\tif(OpenClipboard()) /*打开剪贴板*/\n\t{\n\t\tif(EmptyClipboard())/*清空剪贴板 并使当前打开剪贴板的窗口获取剪贴板的所有权*/\n\t\t{\n\t\t\tIsSetClip=true;\n\t\t\tCString wcs=L\"this is a test\";\n\t\t\tint len=(wcs.GetLength()+1)*sizeof(wchar_t);\n\t\t\t/*申请内存 并返回内存句柄(指向内存链表)  GlobalAlloc(GMEM_MOVEABLE,len) 申请内存 并返回内存句柄指向内存地址*/\n\t\t\tHANDLE hClip=GlobalAlloc(GMEM_MOVEABLE,len);\n\t\t\t/*根据指向内存链表的句柄获取内存地址*/\n\t\t\twchar_t * pBuf=(wchar_t *)GlobalLock(hClip);\n\t\t\twcscpy_s(pBuf,len/2,wcs.GetBuffer(0));\n\t\t\tGlobalUnlock(hClip);\n\t\t\t/*设置剪贴板*/\n\t\t\tSetClipboardData(CF_UNICODETEXT,hClip);\n\t\t\tCloseClipboard();\n\t\t}\n\t}\n}\u003c/pre\u003e"