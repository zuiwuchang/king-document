var __v="\n\u003cpre class='prettyprint linenums'\u003epackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\n//定義一個 樹 結構\ntype Element struct {\n\tK, V int\n\n\t//父節點\n\tP *Element\n\n\t//子節點\n\tL, R *Element\n}\n\n//中順遍歷\nfunc InorderWalk(x *Element) {\n\tif x != nil {\n\t\tInorderWalk(x.L)\n\t\tfmt.Printf(\"key = %03v   val = %03v\\n\", x.K, x.V)\n\t\tInorderWalk(x.R)\n\t}\n}\n\n//查找 key 非遞歸\nfunc Search(x *Element, k int) *Element {\n\tfor x != nil \u0026amp;\u0026amp; x.K != k {\n\t\tif k \u0026lt; x.K {\n\t\t\tx = x.L\n\t\t} else {\n\t\t\tx = x.R\n\t\t}\n\t}\n\treturn x\n}\n\n//查找 key 遞歸\nfunc Search2(x *Element, k int) *Element {\n\tif x == nil || //沒找到\n\t\tx.K == k { //找到\n\t\treturn x\n\t}\n\n\tif k \u0026lt; x.K { //k 太小 查左 子樹\n\t\treturn Search2(x.L, k)\n\t}\n\n\t//k 太大 查右 子樹\n\treturn Search2(x.R, k)\n}\n\n//返回 最大 節點\nfunc Max(x *Element) *Element {\n\tfor x != nil \u0026amp;\u0026amp; x.R != nil {\n\t\tx = x.R\n\t}\n\treturn x\n}\n\n//返回 最小 節點\nfunc Min(x *Element) *Element {\n\tfor x != nil \u0026amp;\u0026amp; x.L != nil {\n\t\tx = x.L\n\t}\n\treturn x\n}\n\n//返回 後繼節點/nil\nfunc Successor(x *Element) *Element {\n\tif x == nil {\n\t\treturn nil\n\t}\n\n\tif x.R != nil { //存在 右子樹\n\t\treturn Min(x.R) //後繼爲 右子樹中 最小元素\n\t}\n\n\t//後繼爲 第一個有 左孩子的 祖先節點\n\ty := x.P\n\tfor y != nil \u0026amp;\u0026amp; x == y.R {\n\t\tx = y\n\t\ty = y.P\n\t}\n\treturn y\n}\n\n//返回 前驅節點/nil\nfunc Predecessor(x *Element) *Element {\n\tif x == nil {\n\t\treturn nil\n\t}\n\n\tif x.L != nil { //存在 左子樹\n\t\treturn Max(x.L) //後繼爲 左子樹中 最大元素\n\t}\n\n\t//後繼爲 第一個有 右孩子的 祖先節點\n\ty := x.P\n\tfor y != nil \u0026amp;\u0026amp; x == y.L {\n\t\tx = y\n\t\ty = y.P\n\t}\n\treturn y\n}\n\n//插入 並返回新的 root 節點\nfunc Insert(root *Element, k, v int) *Element {\n\t//創建 新 節點\n\tz := \u0026amp;Element{K: k, V: v}\n\n\t//記錄 z 的 父節點\n\tvar y *Element\n\t//當前 位置\n\tx := root\n\tfor x != nil {\n\t\tif x.K == k {\n\t\t\t//已經存在key 直接替換\n\t\t\tx.V = v\n\t\t\treturn root\n\t\t}\n\n\t\ty = x\n\t\tif k \u0026lt; x.K {\n\t\t\t//比當前小 比對左子樹\n\t\t\tx = x.L\n\t\t} else {\n\t\t\t//比當前大 比對右子樹\n\t\t\tx = x.R\n\t\t}\n\t}\n\n\t//設置 父節點\n\tz.P = y\n\tif y == nil { //設置新的 root\n\t\troot = z\n\t} else if k \u0026lt; y.K {\n\t\ty.L = z\n\t} else {\n\t\ty.R = z\n\t}\n\treturn root\n}\n\n//以子樹 v 替換 子樹 u 並返回新的 root\nfunc Transplant(root, u, v *Element) *Element {\n\tif u.P == nil { //u爲root節點\n\t\troot = v\n\t} else if u == u.P.L { //u是 左孩子\n\t\tu.P.L = v\n\t} else /*if u==u.P.R*/ { //u是 右孩子\n\t\tu.P.R = v\n\t}\n\n\tif v != nil { //更新 v的 父節點\n\t\tv.P = u.P\n\t}\n\treturn root\n}\n\n//刪除指定節點 並返回新的 root\nfunc Erase(root, z *Element) *Element {\n\t/*\n\t\t沒有孩子 直接刪除(用 nil 樹替換)\n\t\t只有一個孩子(使用 子樹 替換)\n\t*/\n\tif z.L == nil { //沒有 左孩子\n\t\treturn Transplant(root, z, z.R)\n\t} else if z.R == nil { //沒有 右孩子\n\t\treturn Transplant(root, z, z.L)\n\t}\n\n\t/*\t同時有兩個孩子\t*/\n\t//尋找 後繼  (後繼一定 沒有 左子樹)\n\ty := Min(z.R)\n\n\tif y.P != z { //如果 y不是z的 右孩子\n\t\troot = Transplant(root, y, y.R) //用 y.R 替換 原y \n\n\t\t//將 y.R 替換爲 z.R\n\t\ty.R = z.R\n\t\ty.R.P = y\n\t}\n\t//使用 後繼 替換 z\n\troot = Transplant(root, z, y)\n\ty.L = z.L\n\ty.L.P = y\n\treturn root\n}\nfunc main() {\n\trand.Seed(time.Now().Unix())\n\n\tvar root *Element\n\tfor i := 0; i \u0026lt; 12; i++ {\n\t\t//root = Insert(root, rand.Int()%1000, i)\n\t\troot = Insert(root, i, i)\n\t}\n\tInorderWalk(root)\n\tfmt.Println(\"min\", Min(root).K)\n\tfmt.Println(\"max\", Max(root).K)\n\tfmt.Println(\"search\", Search(root, 15))\n\troot = Erase(root, Search(root, 5))\n\tInorderWalk(root)\n}\n\u003c/pre\u003e"