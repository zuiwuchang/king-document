var __v="\u003cpre class=\"k-pre\"\u003e//创建套接字(處於阻塞模式) (失敗返回INVALID_SOCKET )\nSOCKET socket(  int af,  //地址族族 现在一般用AF_INET\n        int type,  \t//SOCK_STREAM(流 tcp) SOCK_DGRAM (数据包 udp) \n        int protocol); //协议 IPPROTO_TCP ... 为0 系统自动判断协议\n\n//将一个未使用的套接字和 一个地址想关联 (失敗返回SOCKET_ERROR)\nint bind(  SOCKET s, \n         const struct sockaddr FAR* name, \n         int namelen);\n\n//将一个未使用的套接字和 一个地址想关联(失敗返回SOCKET_ERROR)\nint listen(\n  __in  SOCKET s,\n  __in  int backlog  //连接队列中最大数值 最大5 SOMAXCONN系统自定义最合理值\n);\n\n        \n//接受一个socket连接 并将新建的socket返回 (失敗返回INVALID_SOCKET )\nSOCKET accept(\n  __in     SOCKET s,\n  __out    struct sockaddr* addr,\t//SOCKADDR_IN  SOCKADDR\n  __inout  int* addrlen\n);\n\n//將網絡地址 轉化為ip\nchar* FAR inet_ntoa(\n  __in  struct   in_addr in\t//addr.sin_addr\n);\n\n//连接socket\t(失敗返回SOCKET_ERROR )\nint connect(  \n        SOCKET s,  \n        const struct sockaddr FAR* name,  \n        int namelen);\n\n//接受数据 (返回失敗實際接收數據大小 [SOCKET_ERROR(-1) 網絡錯誤] \n[==0 socket已經關閉] )\nint recv(\n  __in   SOCKET s,\n  __out  char* buf,\n  __in   int len,\n  __in   int flags\n);\n\n//发送数据 返回值同recv\nint send(  SOCKET s,  \n        const char FAR* buf,  \n        int len,\n          int flags);\n\n//关闭套接字 (失敗返回SOCKET_ERROR )\nint closesocket(\n  __in  SOCKET s\n);\n\n//設置socket為非阻塞\nu_long ul=1; \nioctlsocket(sock,FIONBIO,\u0026amp;ul)\n\n//設置socket為阻塞\nu_long ul=0; \nioctlsocket(sock,FIONBIO,\u0026amp;ul)\nshutdown\n\n//禁止套接字进行某项操作 (失敗返回SOCKET_ERROR )\nint shutdown(\n  __in  SOCKET s,\n  __in  int how\t\t//SD_RECEIVE(禁止讀) SD_SEND(禁止寫) SD_BOTH(兩者都禁)\n);\n\u003c/pre\u003e"