var __v="\n\u003cpre class='prettyprint linenums'\u003e//以子樹 v 替換 子樹 u 並返回新的 root\nfunc Transplant(root, u, v *Element) *Element {\n\tif u.P == nil { //u爲root節點\n\t\troot = v\n\t} else if u == u.P.L { //u是 左孩子\n\t\tu.P.L = v\n\t} else /*if u==u.P.R*/ { //u是 右孩子\n\t\tu.P.R = v\n\t}\n\n\tif v != nil { //更新 v的 父節點\n\t\tv.P = u.P\n\t}\n\treturn root\n}\n\n//刪除指定節點 並返回新的 root\nfunc Erase(root, z *Element) *Element {\n\t/*\n\t\t沒有孩子 直接刪除(用 nil 樹替換)\n\t\t只有一個孩子(使用 子樹 替換)\n\t*/\n\tif z.L == nil { //沒有 左孩子\n\t\treturn Transplant(root, z, z.R)\n\t} else if z.R == nil { //沒有 右孩子\n\t\treturn Transplant(root, z, z.L)\n\t}\n\n\t/*\t同時有兩個孩子\t*/\n\t//尋找 後繼  (後繼一定 沒有 左子樹)\n\ty := Min(z.R)\n\n\tif y.P != z { //如果 y不是z的 右孩子\n\t\troot = Transplant(root, y, y.R) //用 y.R 替換 原y \n\n\t\t//將 y.R 替換爲 z.R\n\t\ty.R = z.R\n\t\ty.R.P = y\n\t}\n\t//使用 後繼 替換 z\n\troot = Transplant(root, z, y)\n\ty.L = z.L\n\ty.L.P = y\n\treturn root\n}\u003c/pre\u003e"