var __v="\u003cpre class=\"k-pre\"\u003e要使表单能够上传文件，首先第一步就是要添加form的enctype属性，enctype属性有如下三种情况:\n\napplication/x-www-form-urlencoded   表示在发送前编码所有字符（默认）\nmultipart/form-data   不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。\ntext/plain    空格转换为 \"+\" 加号，但不对特殊字符编码。\n所以，表单的html代码应该类似于:\n\n\u0026lt;html\u0026gt;\n\u0026lt;head\u0026gt;\n    \u0026lt;title\u0026gt;上传文件\u0026lt;/title\u0026gt;\n\u0026lt;/head\u0026gt;\n\u0026lt;body\u0026gt;\n\u0026lt;form enctype=\"multipart/form-data\" action=\"http://127.0.0.1:9090/upload\" method=\"post\"\u0026gt;\n  \u0026lt;input type=\"file\" name=\"uploadfile\" /\u0026gt;\n  \u0026lt;input type=\"hidden\" name=\"token\" value=\"{{.}}\"/\u0026gt;\n  \u0026lt;input type=\"submit\" value=\"upload\" /\u0026gt;\n\u0026lt;/form\u0026gt;\n\u0026lt;/body\u0026gt;\n\u0026lt;/html\u0026gt;\n在服务器端，我们增加一个handlerFunc:\n\nhttp.HandleFunc(\"/upload\", upload)\n\n// 处理/upload 逻辑\nfunc upload(w http.ResponseWriter, r *http.Request) {\n    fmt.Println(\"method:\", r.Method) //获取请求的方法\n    if r.Method == \"GET\" {\n        crutime := time.Now().Unix()\n        h := md5.New()\n        io.WriteString(h, strconv.FormatInt(crutime, 10))\n        token := fmt.Sprintf(\"%x\", h.Sum(nil))\n\n        t, _ := template.ParseFiles(\"upload.gtpl\")\n        t.Execute(w, token)\n    } else {\n        r.ParseMultipartForm(32 \u0026lt;\u0026lt; 20)\n        file, handler, err := r.FormFile(\"uploadfile\")\n        if err != nil {\n            fmt.Println(err)\n            return\n        }\n        defer file.Close()\n        fmt.Fprintf(w, \"%v\", handler.Header)\n        f, err := os.OpenFile(\"./test/\"+handler.Filename, os.O_WRONLY|os.O_CREATE, 0666)\n        if err != nil {\n            fmt.Println(err)\n            return\n        }\n        defer f.Close()\n        io.Copy(f, file)\n    }\n}\n通过上面的代码可以看到，处理文件上传我们需要调用r.ParseMultipartForm，里面的参数表示maxMemory，调用ParseMultipartForm之后，上传的文件存储在maxMemory大小的内存里面，如果文件大小超过了maxMemory，那么剩下的部分将存储在系统的临时文件中。我们可以通过r.FormFile获取上面的文件句柄，然后实例中使用了io.Copy来存储文件。\n\n获取其他非文件字段信息的时候就不需要调用r.ParseForm，因为在需要的时候Go自动会去调用。而且ParseMultipartForm调用一次之后，后面再次调用不会再有效果。\n通过上面的实例我们可以看到我们上传文件主要三步处理：\n\n表单中增加enctype=\"multipart/form-data\"\n服务端调用r.ParseMultipartForm,把上传的文件存储在内存和临时文件中\n使用r.FormFile获取文件句柄，然后对文件进行存储等处理。\n文件handler是multipart.FileHeader,里面存储了如下结构信息\n\ntype FileHeader struct {\n    Filename string\n    Header   textproto.MIMEHeader\n    // contains filtered or unexported fields\n}\n我们通过上面的实例代码打印出来上传文件的信息如下\n\n\n\n\n\n客户端上传文件\nGo支持模拟客户端表单功能支持文件上传，详细用法请看如下示例：\n\npackage main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"io\"\n    \"io/ioutil\"\n    \"mime/multipart\"\n    \"net/http\"\n    \"os\"\n)\n\nfunc postFile(filename string, targetUrl string) error {\n    bodyBuf := \u0026amp;bytes.Buffer{}\n    bodyWriter := multipart.NewWriter(bodyBuf)\n\n    //关键的一步操作\n    fileWriter, err := bodyWriter.CreateFormFile(\"uploadfile\", filename)\n    if err != nil {\n        fmt.Println(\"error writing to buffer\")\n        return err\n    }\n\n    //打开文件句柄操作\n    fh, err := os.Open(filename)\n    if err != nil {\n        fmt.Println(\"error opening file\")\n        return err\n    }\n    defer fh.Close()\n\n    //iocopy\n    _, err = io.Copy(fileWriter, fh)\n    if err != nil {\n        return err\n    }\n\n    contentType := bodyWriter.FormDataContentType()\n    bodyWriter.Close()\n\n    resp, err := http.Post(targetUrl, contentType, bodyBuf)\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()\n    resp_body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        return err\n    }\n    fmt.Println(resp.Status)\n    fmt.Println(string(resp_body))\n    return nil\n}\n\n// sample usage\nfunc main() {\n    target_url := \"http://localhost:9090/upload\"\n    filename := \"./astaxie.pdf\"\n    postFile(filename, target_url)\n}\n上面的例子详细展示了客户端如何向服务器上传一个文件的例子，客户端通过multipart.Write把文件的文本流写入一个缓存中，然后调用http的Post方法把缓存传到服务器。\u003c/pre\u003e"