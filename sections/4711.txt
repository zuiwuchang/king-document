var __v="\n\u003cpre class='prettyprint linenums'\u003epackage email\n\nimport (\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"net/smtp\"\n\t\"strings\"\n)\n\nconst (\n\t// TypeHTML .\n\tTypeHTML = \"html\"\n)\n\n// ErrWriteBusy tcp 發送緩衝區 已滿\nvar ErrWriteBusy = errors.New(\"write busy\")\n\nvar errUnexpectedServerChallenge = errors.New(\"unexpected server challenge\")\n\n// InsecureAuth 非加密的 email 驗證\ntype InsecureAuth struct {\n\tUser, Pwd string\n}\n\n// Start .\nfunc (a *InsecureAuth) Start(server *smtp.ServerInfo) (string, []byte, error) {\n\tresp := []byte(\"\\x00\" + a.User + \"\\x00\" + a.Pwd)\n\treturn \"PLAIN\", resp, nil\n}\n\n// Next .\nfunc (*InsecureAuth) Next(fromServer []byte, more bool) ([]byte, error) {\n\tif more {\n\t\t// We've already sent everything.\n\t\treturn nil, errUnexpectedServerChallenge\n\t}\n\treturn nil, nil\n}\n\nfunc writeMsg(w io.Writer,\n\tuser, to,\n\tsubject, body,\n\tmailtype string) (e error) {\n\n\t// msg\n\tmsg := \"To: \" + to +\n\t\t\"\\r\\nFrom: \" + user + \"\u0026lt;\" + user +\n\t\t\"\u0026gt;\\r\\nSubject: \" + subject + \"\\r\\n\" +\n\t\t\"Content-Type: text/\" + mailtype + \"; charset=UTF-8\\r\\n\\r\\n\" + body\n\n\t// write\n\tvar n int\n\tn, e = w.Write([]byte(msg))\n\tif e != nil {\n\t\treturn\n\t} else if n != len(msg) {\n\t\te = ErrWriteBusy\n\t}\n\treturn\n}\n\nfunc sendEmail(c *smtp.Client,\n\tuser, to,\n\tsubject, body,\n\tmailtype string) (e error) {\n\n\t// 設置 發信地址\n\tif e = c.Mail(user); e != nil {\n\t\treturn\n\t}\n\n\t//設置 收信 地址\n\tsendToS := strings.Split(to, \";\")\n\tfor _, sendTo := range sendToS {\n\t\tif e = c.Rcpt(sendTo); e != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\t// 創建 writer\n\tvar w io.WriteCloser\n\tw, e = c.Data()\n\tif e != nil {\n\t\treturn\n\t}\n\n\t// 寫入 發送數據\n\te = writeMsg(w,\n\t\tuser, to,\n\t\tsubject, body,\n\t\tmailtype,\n\t)\n\t// 發送 結束\n\te = w.Close()\n\treturn\n}\n\n// SendEmail 使用非 加密 發送 email\nfunc SendEmail(host,\n\tuser, pwd, to,\n\tsubject, body,\n\tmailtype string,\n) (e error) {\n\t// 創建 客戶端\n\tvar c *smtp.Client\n\tc, e = NewSMTPClient(host, user, pwd)\n\tif e != nil {\n\t\treturn\n\t}\n\n\t// 發送 email\n\te = sendEmail(c,\n\t\tuser, to,\n\t\tsubject, body,\n\t\tmailtype,\n\t)\n\tif e == nil {\n\t\tc.Quit()\n\t} else {\n\t\tc.Close()\n\t}\n\treturn\n}\n\n// SendSSLEmail 使用 ssl 發送 email\nfunc SendSSLEmail(host,\n\tuser, pwd, to,\n\tsubject, body,\n\tmailtype string,\n) (e error) {\n\t// 創建 客戶端\n\tvar c *smtp.Client\n\tc, e = NewSMTPSSLClient(host, user, pwd)\n\tif e != nil {\n\t\treturn\n\t}\n\n\t// 發送 email\n\te = sendEmail(c,\n\t\tuser, to,\n\t\tsubject, body,\n\t\tmailtype,\n\t)\n\tif e == nil {\n\t\tc.Quit()\n\t} else {\n\t\tc.Close()\n\t}\n\treturn\n}\n\n// NewSMTPClient 創建一個 未加密 的 smtp 客戶端\nfunc NewSMTPClient(host, user, pwd string) (c *smtp.Client, e error) {\n\t// 創建 smtp 客戶端\n\tc, e = smtp.Dial(host)\n\tif e != nil { // 失敗會自動 tc.Close\n\t\treturn\n\t}\n\n\t// 驗證\n\te = c.Auth(\u0026amp;InsecureAuth{\n\t\tUser: user,\n\t\tPwd:  pwd,\n\t})\n\tif e != nil {\n\t\tc = nil\n\t}\n\treturn\n}\n\n// NewSMTPSSLClient 創建一個 使用 tls 的 smtp 客戶端\nfunc NewSMTPSSLClient(host, user, pwd string) (c *smtp.Client, e error) {\n\t// 建立 tls 連接\n\tvar serverName string\n\tserverName, _, e = net.SplitHostPort(host)\n\tif e != nil {\n\t\treturn\n\t}\n\n\tvar tc *tls.Conn\n\ttc, e = tls.Dial(\n\t\t\"tcp\",\n\t\thost,\n\t\t\u0026amp;tls.Config{\n\t\t\tServerName:         serverName,\n\t\t\t// InsecureSkipVerify: true, // 如果為 true 不驗證 證書\n\t\t},\n\t)\n\tif e != nil {\n\t\treturn\n\t}\n\n\t// 創建 smtp 客戶端\n\tc, e = smtp.NewClient(tc, serverName)\n\tif e != nil { // 失敗會自動 tc.Close\n\t\treturn\n\t}\n\t// 驗證\n\te = c.Auth(smtp.PlainAuth(\"\", user, pwd, serverName))\n\tif e != nil { // 失敗會自動 Close\n\t\tc = nil\n\t}\n\treturn\n}\n\u003c/pre\u003e"