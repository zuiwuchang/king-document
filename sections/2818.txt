var __v="\u003cpre class=\"k-pre\"\u003e//打开注册表键\nLONG RegOpenKeyEx(\n\tHKEY hKey,         // handle to open key主键\n\tLPCTSTR lpSubKey,  // subkey name子键\n\tDWORD ulOptions,   // reserved。必须是0\n\tREGSAM samDesired, // security access mask读写标识\n\tPHKEY phkResult    // handle to open key返回的HKEY类型的指针。以后，读写，关闭用这个指针\n);\n\u003cpre class='prettyprint linenums'\u003e// 打开HKEY_LOCAL_MACHINE主键下的SoftWare\\\\Cleaner\\\\Cleaner子键\nHKEY hKEY;\nHKEY  hKeyRoot = HKEY_LOCAL_MACHINE;\nlong ret0=(RegOpenKeyEx(hKeyRoot,\"SoftWare\\\\Cleaner\\\\Cleaner\",0,KEY_READ,\u0026amp;hKEY));\nif(ret0!=ERROR_SUCCESS)// 如果无法打开hKEY,则中止程序的执行\n{\n\tAfxMessageBox(\"错误：无法打开有关的hKEY\");\n\treturn;\n}\u003c/pre\u003e\n//读取注册表\nLONG RegQueryValueEx(\n\tHKEY hKey,            // handle to key打开注册表指针\n\tLPCTSTR lpValueName,  // value name要读取的键名称\n\tLPDWORD lpReserved,   // reserved  must be NULL. 必须是NULL\n\tLPDWORD lpType,       // type buffer，键类型。我最常用REG_SZ,REG_DWORD\n\tLPBYTE lpData,        // data buffer。保存查询结果的缓冲区\n\tLPDWORD lpcbData      // size of data buffer。缓冲区大小\n);\n\u003cpre class='prettyprint linenums'\u003e// hKEY是上面打开时得到的指针。\nLPBYTE getValue = new BYTE[80];//得到的键值\nDWORD keyType = REG_SZ;//定义数据类型\nDWORD DataLen = 80;//定义数据长度\nCString strUser = _T(\"Version\");//要查询的键名称\nlong ret1=RegQueryValueEx(hKEY,strUser,NULL,\u0026amp;keyType,getValue,\u0026amp;DataLen);\nif(ret1!=ERROR_SUCCESS)\n{\n\tAfxMessageBox(\"错误：无法查询有关的注册表信息\");\n\treturn;\n}\u003c/pre\u003e\n//写注册表\nLONG RegSetValueEx(\n\tHKEY hKey,           // handle to key。打开注册表的指针\n\tLPCTSTR lpValueName, // value name 要写入的键\n\tDWORD Reserved,      // reserved  必须是0\n\tDWORD dwType,        // value type 写入值类型\n\tCONST BYTE *lpData,  // value data 要写入的数据\n\tDWORD cbData         // size of value data 。数据SIZE\n);\n\u003cpre class='prettyprint linenums'\u003e// 写注册表。修改Version为1.0.12\n// 写入CString类型的数据\nCString strVersion = _T(\"Version\");//要写入的键名称\nLPCTSTR strVersionValue = \"1.0.12\";\nlong ret = ::RegSetValueEx(hKEY, strVersion, 0, REG_SZ, (const BYTE *) strVersionValue, strlen(strVersionValue)+1);\nif(ret!=ERROR_SUCCESS)\n{\n\tAfxMessageBox(\" 错误：无法查询有关的注册表信息\");\n\treturn;\n}\u003c/pre\u003e\n//创建一个新键\nLONG RegCreateKeyEx(\n\tHKEY hKey,                                  // handle to open key。打开的注册表指针\n\tLPCTSTR lpSubKey,                           // subkey name。子键名称\n\tDWORD Reserved,                             // reserved。必须为0\n\tLPTSTR lpClass,                             // class string。已经存在时用，一般为NULL\n\tDWORD dwOptions,                            // special options\n\t//默认值REG_OPTION_VOLATILE，保存在注册表，下次开机仍然存在\n\t//REG_OPTION_VOLATILE，保存在内存\n\t//REG_OPTION_BACKUP_RESTORE\n\tREGSAM samDesired,                          // desired security access。操作权限。一般KEY_ALL_ACCESS，除非有特殊需要，请查阅MSDN\n\tLPSECURITY_ATTRIBUTES lpSecurityAttributes, // inheritance。继承性。一般为NULL\n\tPHKEY phkResult,                            // key handle 。返回该键值镇。\n\tLPDWORD lpdwDisposition                     // disposition value buffer\n\t//REG_CREATED_NEW_KEY The key did not exist and was created. \n\t//REG_OPENED_EXISTING_KEY The key existed and was simply opened without being changed.\n);\n\n//删除一个键\nLONG RegDeleteKey(\nHKEY hKey,         // handle to open key\nLPCTSTR lpSubKey   // subkey name\n);\n\n//删除一个键值\nLONG RegDeleteValue(\nHKEY hKey,            // handle to key\nLPCTSTR lpValueName   // value name。值名称，不是打开的那个指针，是查询到的指针，如果为空RegSetValueEx创建的值将被删除\n);\n\n//刷新注册表\nLONG RegFlushKey(\nHKEY hKey   // handle to key to write。写入所有的值，在给定的指针\n);\n//这个函数是将改变数据直接写到硬盘上，不要频繁使用，会影响性能\n\n...\n\u003c/pre\u003e"