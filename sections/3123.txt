var __v="\u003cpre class=\"k-pre\"\u003e//創建 io completion port 失敗返回NULL\nHANDLE\tCreateIoCompletionPort(INVALID_HANDLE_VALUE,NULL,0\t//對於創建 前三個參數固定\n\t,0\t//0系統默認(顯一個cpu一線程)\t指定並發執行的線程數 \n)\n\n//關聯 io completion port 和 一個以FILE_FLAG_OVERLAPPED 打開的設備 (失敗返回NULL,否則返回ExistingCompletionPort)\nHANDLE WINAPI CreateIoCompletionPort(\n  __in      HANDLE FileHandle,\t\t\t\t//要關聯的設備句柄(FILE_FLAG_OVERLAPPED)\n  __in_opt  HANDLE ExistingCompletionPort,\t// 一個已經存在的io completion por 句柄\n  __in      ULONG_PTR CompletionKey,\t\t//用戶自定義的一個 32位值 通常是一個 用戶自定義數據的指針\n  __in      DWORD NumberOfConcurrentThreads //0\n);\n\n//等待 io completion port  失敗返回NULL\nBOOL WINAPI GetQueuedCompletionStatus(\n  __in   HANDLE CompletionPort,\t\t\t\t// io completion port 句柄\n  __out  LPDWORD lpNumberOfBytes,\t\t\t//被傳輸字節數\n  __out  PULONG_PTR lpCompletionKey,\t\t//CreateIoCompletionPort中傳入的 用戶自定義32位值\n  __out  LPOVERLAPPED* lpOverlapped,\t\t//一個LPOVERLAPPED 指針 返回完成的overlapped結構地址\n  __in   DWORD dwMilliseconds\t\t\t\t//等待超時 INFINITE 一直等待\n);\n\n\n//模擬io完成 向 io completion port 發送一個 模擬的 io completion pack\nBOOL WINAPI PostQueuedCompletionStatus(\n  __in      HANDLE CompletionPort,\t\t\t\t// io completion handle\n  __in      DWORD dwNumberOfBytesTransferred,\t//對於GetQueuedCompletionStatus的傳出參數\n  __in      ULONG_PTR dwCompletionKey,\t\t\t//...\n  __in_opt  LPOVERLAPPED lpOverlapped\t\t\t//...\n);\n\u003c/pre\u003e"