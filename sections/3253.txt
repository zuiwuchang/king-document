var __v="\n\u003cpre class='prettyprint linenums'\u003e#include \"Driver.h\"\n\n//导入KeServiceDescriptorTable表\nextern \"C\" ULONG KeServiceDescriptorTable;\n//记录原函数地址\nHookNtOpenProcess realNtOpenProcess;\n//记录被保护进程 pid\nHANDLE protected_pid;\n//记录是否被保护\nbool isHook=false;\n\n#pragma INIT_MEMORY\nextern \"C\" NTSTATUS DriverEntry (IN PDRIVER_OBJECT pDriverObject,IN PUNICODE_STRING pRegistryPath\t) \n{\n\tKdPrint((\"DriverEntry begin\\n\"));\n\t//__asm int 3;\n\t\n\tNTSTATUS status;\n\n\t//注册设备卸载例程\n\tpDriverObject-\u0026gt;DriverUnload = UnloadDevice;\n\n\t////注册irp例程\n\tpDriverObject-\u0026gt;MajorFunction[IRP_MJ_CREATE] = CreateDispatchRoutine;\n\tpDriverObject-\u0026gt;MajorFunction[IRP_MJ_CLOSE] = CloseDispatchRoutine;\n\n\t\n\tpDriverObject-\u0026gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlDispatchRoutine;\n\t//创建驱动设备对象\n\tstatus = CreateDevice(pDriverObject);\n\n\tKdPrint((\"DriverEntry end\\n\"));\n\treturn status;\n}\n\n\n#pragma INIT_MEMORY\nULONG GetCurFunctionAddr(ULONG index)\n{\n\tULONG function_addr;\n\t__asm\n\t{\n\t\tpush eax;\n\t\tpush ebx;\n\t\t\tmov eax,KeServiceDescriptorTable;\n\t\t\tmov eax,[eax];\n\t\t\tmov ebx,index;\t//函数索引\n\t\t\tshl ebx,2;\t\t//计算函数偏移 左移两位 相当于*4 或 imul ebx,ebx,4 \n\t\t\tadd eax,ebx;\t\n\t\t\tmov eax,[eax];\n\t\t\tmov function_addr,eax;\n\t\tpop ebx;\n\t\tpop eax;\n\t}\n\treturn function_addr;\n}\n\n#pragma INIT_MEMORY\nULONG SetCurFunctionAddr(ULONG index,ULONG addr)\n{\n\tULONG function_addr;\n\t__asm\n\t{\n\t\tpush eax;\n\t\tpush ebx;\n\n\t\t//去除页面保护\n\t\tcli;\n\t\t\tmov eax,cr0;\n\t\t\tand eax,not 10000h; //and eax,0FFFEFFFFh\n\t\t\tmov cr0,eax;\n\n\t\t\tmov eax,KeServiceDescriptorTable;\n\t\t\tmov eax,[eax];\n\t\t\tmov ebx,index;\t//函数索引\n\t\t\tshl ebx,2;\t\t//计算函数偏移 左移两位 相当于*4 或 imul ebx,ebx,4 \n\t\t\tadd eax,ebx;\n\t\t\tmov ebx,[eax];\n\t\t\tmov function_addr,ebx;\n\n\t\t\tmov ebx,addr;\n\t\t\tmov [eax],ebx;\n\t\t\n\t\t//恢复页面保户\n\t\tcli;\n\t\t\tmov eax,cr0;\n\t\t\tor eax,10000h; \n\t\t\tmov cr0,eax ;\n\t\t\tsti;\n\n\t\tpop ebx;\n\t\tpop eax;\n\t}\n\treturn function_addr;\n}\n\n#pragma INIT_MEMORY\nNTSTATUS CreateDevice (IN PDRIVER_OBJECT pDriverObject) \n{\n\tKdPrint((\"CreateDevice begin\\n\"));\n\n\tNTSTATUS status;\n\t//设备对象 指针\n\tPDEVICE_OBJECT pDevObj;\n\t//设备对象扩展结构 指针\n\tPDEVICE_EXTENSION pDevExt;\n\t\n\t//设备名称\n\tUNICODE_STRING devName;\n\tRtlInitUnicodeString(\u0026amp;devName,L\"\\\\Device\\\\SSDT_HOOK\");\n\t\n\t//创建设备\n\tstatus = IoCreateDevice( pDriverObject,\t\t\t//驱动对象\n\t\t\t\t\t\tsizeof(DEVICE_EXTENSION),\t//设备扩展结构大小\n\t\t\t\t\t\t\u0026amp;(UNICODE_STRING)devName,\t//设备名 或 NULL\n\t\t\t\t\t\tFILE_DEVICE_UNKNOWN,\t\t//设备类型 FILE_DEVICE_UNKNOWN 未知虚拟设备，且为独占(既只能被一个应用程序使用) \n\t\t\t\t\t\t0, TRUE,\n\t\t\t\t\t\t\u0026amp;pDevObj );\t\t\t\t\t//设备地址 out\n\n\tif (!NT_SUCCESS(status))\n\t\treturn status;\n\n\t//以直接的方式读写(既不使用缓冲区)\n\tpDevObj-\u0026gt;Flags |= DO_DIRECT_IO;\n\n\t//填充扩展结构数据\n\tpDevExt = (PDEVICE_EXTENSION)pDevObj-\u0026gt;DeviceExtension;\n\tpDevExt-\u0026gt;pDevice = pDevObj;\n\tpDevExt-\u0026gt;ustrDeviceName = devName;\n\t\n\t//符号链接名\n\tUNICODE_STRING symLinkName;\n\tRtlInitUnicodeString(\u0026amp;symLinkName,L\"\\\\??\\\\SSDT_HOOK\");\n\t\n\t//创建符号链接\n\tpDevExt-\u0026gt;ustrSymLinkName = symLinkName;\n\tstatus = IoCreateSymbolicLink( \u0026amp;symLinkName,\u0026amp;devName );\n\t\n\tif (!NT_SUCCESS(status)) \n\t{\n\t\tIoDeleteDevice( pDevObj );\n\t\treturn status;\n\t}\n\t\n\tKdPrint((\"CreateDevice sucess and end\\n\"));\n\treturn STATUS_SUCCESS;\n}\n\n\n\n#pragma PAGE_MEMORY\nVOID UnloadDevice (IN PDRIVER_OBJECT pDriverObject) \n{\n\tKdPrint((\"UnloadDevice begin\\n\"));\n\t\n\t//获取设备链表 加载的设备被自动保存在一个链表中\n\tPDEVICE_OBJECT\tpNextObj = pDriverObject-\u0026gt;DeviceObject;\n\t\n\t//遍历设备链表\n\twhile (pNextObj) \n\t{\n\t\t//获取设备扩展结构\n\t\tPDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)pNextObj-\u0026gt;DeviceExtension;\n\n\t\t//删除符号链接\n\t\tUNICODE_STRING pLinkName = pDevExt-\u0026gt;ustrSymLinkName;\n\t\tIoDeleteSymbolicLink(\u0026amp;pLinkName);\n\t\t\n\t\t//删除设备\n\t\tIoDeleteDevice(pNextObj);\n\n\t\t//指向链表下一节点\n\t\tpNextObj = pNextObj-\u0026gt;NextDevice;\n\t}\n\n\tKdPrint((\"UnloadDevice end\\n\"));\n}\n\n\n\n\n#pragma PAGE_MEMORY\nNTSTATUS DispatchRoutine(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp) \n{\n\tKdPrint((\"DispatchRoutine begin\\n\"));\n\t\n\t//...根据要实现的功能\n\t//...完成一些事情\n\t//...代码省略\n\n\tNTSTATUS status = STATUS_SUCCESS;\n\t//设置完成irp状态 是否成功等\n\tpIrp-\u0026gt;IoStatus.Status = status;\n\t//设置irp实际操作字节数\n\tpIrp-\u0026gt;IoStatus.Information = 0;\t// bytes xfered\n\t//指示完成此irp\n\tIoCompleteRequest( pIrp, IO_NO_INCREMENT );\n\t\n\tKdPrint((\"DispatchRoutine end\\n\"));\n\treturn status;\n}\n#pragma PAGE_MEMORY\nNTSTATUS CreateDispatchRoutine(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp)\n{\n\tKdPrint((\"CreateDispatchRoutine begin\\n\"));\n\t\n\tNTSTATUS status = STATUS_SUCCESS;\n\t//...根据要实现的功能\n\t//...完成一些事情\n\t//...代码省略\n\n\tIoCompleteRequest( pIrp, IO_NO_INCREMENT );\n\tKdPrint((\"CreateDispatchRoutine end\\n\"));\n\treturn status;\n}\n#pragma PAGE_MEMORY\nNTSTATUS CloseDispatchRoutine(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp)\n{\n\tKdPrint((\"CloseDispatchRoutine begin\\n\"));\n\t\n\tNTSTATUS status = STATUS_SUCCESS;\n\tUnHook();\n\tIoCompleteRequest( pIrp, IO_NO_INCREMENT );\n\tKdPrint((\"CloseDispatchRoutine end\\n\"));\n\treturn status;\n}\n#pragma PAGE_MEMORY\nNTSTATUS ControlDispatchRoutine(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp)\n{\n\tKdPrint((\"ControlDispatchRoutine begin\\n\"));\n\t\n\tNTSTATUS status = STATUS_NOT_SUPPORTED;\n\tpIrp-\u0026gt;IoStatus.Information=0; //设置返回的实际操作字节数 无实意(既程序员自定)\n\n\t//从irp堆栈结构中 获取设备对象的 irp 结构\n\tPIO_STACK_LOCATION lpIoStack=IoGetCurrentIrpStackLocation(pIrp);\n\n\t//如果成功获取到 irp 结构\n\tif(lpIoStack)\n\t{\n\t\t//判断控制码\n\t\tswitch(lpIoStack-\u0026gt;Parameters.DeviceIoControl.IoControlCode)\n\t\t{\n\t\tcase IOCTL_DIRECT_IN://写如到驱动\n\t\t\tstatus=WriteDirectIn(pIrp,lpIoStack-\u0026gt;Parameters.DeviceIoControl.InputBufferLength,lpIoStack-\u0026gt;Parameters.DeviceIoControl.OutputBufferLength);\n\t\t\tbreak;\n\t\tcase IOCTL_DIRECT_HOOK://从驱动读数据到用户层\n\t\t\tstatus=STATUS_SUCCESS;\n\t\t\tHook();\n\t\t\tbreak;\n\t\tcase IOCTL_DIRECT_UNHOOK:\n\t\t\tstatus=STATUS_SUCCESS;\n\t\t\tUnHook();\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\t//设置pIrp状态 否则驱动无法继续进行其他工作\n\tpIrp-\u0026gt;IoStatus.Status=STATUS_SUCCESS;//返回成功\n\tIoCompleteRequest( pIrp, IO_NO_INCREMENT );\n\tKdPrint((\"ControlDispatchRoutine end\\n\"));\n\treturn status;\n}\n\n\n#pragma PAGE_MEMORY\nNTSTATUS WriteDirectIn(IN PIRP pIrp,ULONG inSize,ULONG outSize)\n{\n\tKdPrint((\"WriteDirectIn begin\\n\"));\n\tNTSTATUS status = STATUS_SUCCESS;\n\n\t//获取用户层传入的 输入缓冲区内容拷贝 的地址\n\tPVOID lp_input_buffer=pIrp-\u0026gt;AssociatedIrp.SystemBuffer;\n\n\t__asm\n\t{\n\t\tpush eax;\n\t\tmov eax,lp_input_buffer;\n\t\tmov eax,[eax];\n\t\tmov protected_pid,eax;\n\t\tpop eax;\n\t}\n\tKdPrint((\"WriteDirectIn pid=%d\\n\",protected_pid));\n\t\n\t\n\tpIrp-\u0026gt;IoStatus.Information=4;\n\n\tKdPrint((\"WriteDirectIn end%d\\n\"));\n\n\treturn status;\n}\n\n\n#pragma PAGE_MEMORY\nvoid Hook()\n{\n\tKdPrint((\"HOOK begin\\n\"));\n\t\n\tif(!isHook)\n\t{\n\t\tULONG index=0xbe;\n\t\trealNtOpenProcess=(HookNtOpenProcess)SetCurFunctionAddr(index,(ULONG)MyNtOpenProcess);\n\t\tisHook=true;\n\t}\n\tKdPrint((\"HOOK end%d\\n\"));\n\t\n}\n\n#pragma PAGE_MEMORY\nvoid UnHook()\n{\n\tKdPrint((\"UNHOOK begin\\n\"));\n\t\n\tULONG index=0xbe;\n\tif(isHook)\n\t{\n\t\tSetCurFunctionAddr(index,(ULONG)realNtOpenProcess);\n\t\tisHook=false;\n\t}\n\tKdPrint((\"UNHOOK end%d\\n\"));\n\t\n}\n\n#pragma PAGE_MEMORY\nextern \"C\" NTSTATUS __stdcall MyNtOpenProcess( \n\tOUT\tPHANDLE ProcessHandle, \n\tIN\tACCESS_MASK DesiredAccess, \n\tIN\tPOBJECT_ATTRIBUTES ObjectAttributes, \n\tIN\tPCLIENT_ID ClientId ) \n{ \n\tNTSTATUS status=STATUS_SUCCESS; \n\t\n\t//调用原 NtOpenProcess\n\tstatus=(NTSTATUS)realNtOpenProcess( ProcessHandle, DesiredAccess, ObjectAttributes, ClientId ); \t\n\n\t//如果 NtOpenProcess 调用成功\n\tif(ClientId) \n\t{ \n\t\t//获取被打开进程 pid\n\t\tHANDLE pid = ClientId-\u0026gt;UniqueProcess; \t \n\n\t\t// 如果是被保护的PID，则拒绝访问，并将句柄设置为空 \n\t\tif(pid == protected_pid) \n\t\t{ \n\t\t\tProcessHandle=NULL;\n\t\t\tstatus=STATUS_ACCESS_DENIED;\n\t\t\t//PsLookupProcessByProcessId((ULONG)PID,\u0026amp;EP);\n\t\t\t/*获取调用此函数的 未公开结构 以获得其进程名\n\t\t\tEP=PsGetCurrentProcess();\t\t\t \n\t\t\tKdPrint((\" ACESS Process Name  --:%s--   \\n\",(PTSTR)((ULONG)EP+0x174)));\n\t\t\t*/\n\t\t} \n\t} \n\n\treturn status; \n} \u003c/pre\u003e"