var __v="\n\u003cpre class='prettyprint linenums'\u003e#include\u0026lt;boost\\thread.hpp\u0026gt;\n#include\u0026lt;boost\\asio.hpp\u0026gt;\n#include\u0026lt;boost\\smart_ptr.hpp\u0026gt;\n#include\u0026lt;boost\\bind.hpp\u0026gt;\n\ntypedef boost::shared_ptr\u0026lt;std::vector\u0026lt;char\u0026gt;\u0026gt; net_data_ptr_t;\ntypedef boost::shared_ptr\u0026lt;boost::asio::ip::udp::endpoint\u0026gt;\tendpoint_ptr_t;\n\nclass server\n{\nprivate:\n\t//前攝器\n\tboost::asio::io_service ios_;\n\n\tboost::asio::ip::udp::socket socket_;\n\n\tunsigned int buffer_length_;\npublic:\n\tserver(const boost::asio::ip::udp::endpoint\u0026amp; endpoint,const unsigned int buffer_length\t=\t1024)\n\t\t: buffer_length_(buffer_length)\n\t\t,socket_(ios_,endpoint)\n\t{\n\t\tunsigned int count\t=\tboost::thread::hardware_concurrency()  + 2;\n\t\tfor(unsigned int i = 0 ; i \u0026lt; count ; ++i)\n\t\t{\n\t\t\tpost_read();\n\t\t}\n\t}\n\tinline void run()\n\t{\n\t\tios_.run();\n\t}\nprotected:\n\tvoid post_read()\n\t{\n\t\tnet_data_ptr_t net_data_ptr\t=\tboost::make_shared\u0026lt;std::vector\u0026lt;char\u0026gt;\u0026gt;(buffer_length_,0);\n\t\tendpoint_ptr_t\tendpoint_ptr\t=\tboost::make_shared\u0026lt;boost::asio::ip::udp::endpoint\u0026gt;();\n\t\n\t\tsocket_.async_receive_from(boost::asio::buffer(*net_data_ptr)\n\t\t\t,*endpoint_ptr\n\t\t\t,boost::bind(\u0026amp;server::read_handler\n\t\t\t\t,this\n\t\t\t\t,boost::asio::placeholders::error\n\t\t\t\t,boost::asio::placeholders::bytes_transferred\n\t\t\t\t,endpoint_ptr\n\t\t\t\t,net_data_ptr\n\t\t\t\t)\n\t\t\t);\n\t}\n\tvoid read_handler(const boost::system::error_code\u0026amp; e,std::size_t size,endpoint_ptr_t endpoint_ptr,net_data_ptr_t net_data_ptr)\n\t{\n\t\tif(!e)\n\t\t{\n\t\t\tunsigned short port\t=\tendpoint_ptr-\u0026gt;port();\n\t\t\tstd::string str\t=\tendpoint_ptr-\u0026gt;address().to_string();\n\n\t\t\t//沒有錯誤 讀出數據 \n\t\t\tprintf(\"%s:%s\\n\",endpoint_ptr-\u0026gt;address().to_string().c_str(),net_data_ptr-\u0026gt;data());\n\n\t\t\t{\n\t\t\t\t//封包\n\t\t\t\tstd::string str\t=\t\"i know\";\n\t\t\t\tnet_data_ptr_t send_data\t=\tboost::make_shared\u0026lt;std::vector\u0026lt;char\u0026gt;\u0026gt;(str.size() + 1,0);\n\t\t\t\tmemcpy(send_data-\u0026gt;data(),str.data(),str.size());\n\t\t\t\t//發送數據\n\t\t\t\tpost_send(endpoint_ptr,send_data);\n\t\t\t}\n\t\t}\n\t\t//讀取新內容\n\t\tpost_read();\n\t}\n\npublic:\n\tvoid post_send(endpoint_ptr_t endpoint_ptr,net_data_ptr_t net_data_ptr)\n\t{\n\t\tsocket_.async_send_to(boost::asio::buffer(*net_data_ptr)\n\t\t\t,*endpoint_ptr\n\t\t\t,boost::bind(\u0026amp;server::send_handler\n\t\t\t\t,this\n\t\t\t\t,boost::asio::placeholders::error\n\t\t\t\t,endpoint_ptr\n\t\t\t\t,net_data_ptr\n\t\t\t\t,0\n\t\t\t\t)\n\t\t\t);\n\n\t\tunsigned short port\t=\tendpoint_ptr-\u0026gt;port();\n\t\tstd::string str\t=\tendpoint_ptr-\u0026gt;address().to_string();\n\n\t}\nprotected:\n\tvoid send_handler(const boost::system::error_code\u0026amp; e,endpoint_ptr_t endpoint_ptr,net_data_ptr_t net_data_ptr,int count/*記錄發送次數*/)\n\t{\n\t\tif(e\n\t\t\t\u0026gt;\u0026gt; count \u0026lt; 5\n\t\t\t)\n\t\t{\n\t\t\t//如果發送失敗 且重發次數小於5 重發\n\t\t\tsocket_.async_send_to(boost::asio::buffer(*net_data_ptr)\n\t\t\t\t,*endpoint_ptr\n\t\t\t\t,boost::bind(\u0026amp;server::send_handler\n\t\t\t\t\t,this\n\t\t\t\t\t,boost::asio::placeholders::error\n\t\t\t\t\t,endpoint_ptr\n\t\t\t\t\t,net_data_ptr\n\t\t\t\t\t,count + 1\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t}\n\t}\n\n};\n\n\n\nint main(int, char*[])\n{\n\tboost::asio::ip::udp::endpoint endpoint(boost::asio::ip::udp::v4(),53);\n\tserver s(endpoint);\n\ts.run();\n\n\tstd::system(\"pause\");\n    return 0;\n}\u003c/pre\u003e"