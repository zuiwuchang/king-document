var __v="\u003cpre class=\"k-pre\"\u003epython 包含 如下 8個 關鍵要素\n\n\n數據型別\n\tint\n\t\t-973\n\t\t1234567890\n\t\t(phton 整數大小 只受限於 內存)\n\n\tstr\n\t\t\"可用雙引號\"\n\t\t'可用單引號'\n\t\t(可以使用 [] 獲取 字符 但無法修改\n\t\tpython中 字符串 是 const 型別\n\t\t實際上 python 沒有 字符 字符是 長度為1的 字符串)\n\n\t(型別 轉化 寫法 同 go[好吧其實是 go 借鑒的 python語法]\n\tint(\"  123 \"))\n\n\n\n對象引用\n\t(python 作用 對象引用 將 變量 與 內存對象 聯繫\n\t使用 引用計數 自動管理 內存\n\n\tpython 包括 int 也是 一個 到 內存 int的 引用\n\t只不過 其和 字符串一樣 是 const 型別\n\tx=1\n\tprint(type(x)))\n\n\n\n組合數據\n\t元組(boost::tuple) 使用 () 定義\n\t列表(std::vector) 使用 [] 定義\n\t\t(\n\t\t\tt = (1,2,3)\n\t\t\tprint(t,t[0],len(t),type(t))\n\n\t\t\tl = [1,2,3]\n\t\t\tl.append(4)\n\t\t\tprint(l,l[0],len(l),type(l))\n\t\t)\n\t...\n\n\n\n邏輯運算符\n\tis\n\tis not\n\t\t(返回 兩個 變量 是否 指向同1 對象\n\t\tx = (1,2,3)\n\t\ty = (1,2,3)\n\t\tprint(x is y) #False)\n\n\t!=\n\t==\n\t...\n\t\t(比較 對象的值)\n\n\tin\n\tnot in\n\t\t(x=[1,2,3]\n\t\tprint(2 in x) #True\n\t\t)\n\n\tand\n\tor\n\tnot\n\t\t(and or 不返回 true/false 而是決定 結果的操作數)\n\n\n\n控制語句\n\tif\n\t(\n\t\tif bool :\n\t\t\t...\n\t\telif bool :\n\t\t\t...\n\t\telse:\n\t\t\t...\n\t)\n\twhile\n\t(\n\t\twhile bool:\n\t\t\t...\n\t)\n\tfor\n\t(\n\tfor v in iterable:\n\t\t...\n\t)\n\n\ttry\n\t(\n\t\ttry\n\t\t\t...\n\t\texcept e1 [as v1]:\n\t\t\t...\n\t\t...\n\t\texcept eN [as vN]:\n\t\t\t...\n\t)\n\n\n\n算術運算\n\t+\n\t-\n\t*\n\t/\n\t//\n\t...=\n\t...\n\n\n\n輸入/輸出\n\t(\n\t\twhile True:\n\t\t\tline = input(\"$\")\n\t\t\tif line == \"q\":\n\t\t\t\tbreak\n\n\t\t\ttry:\n\t\t\t\tnumber = int(line)\n\t\t\t\tprint(\"you input number : \",number)\n\t\t\texcept ValueError:\n\t\t\t\tprint(\"you input string : \",line)\n\t)\n\n\n函數的 創建/調用\n\tdef funName(args ...)\n\t(\n\t\tdef Min(l,r):\n\t\t\tif l \u0026gt; r:\n\t\t\t\treturn r\n\t\t\treturn l\n\t\tprint(Min(1,2))\n\t)\n\t(每個函數 有1個 返回值 默認 None\n\t函數可返回 多個值 會被包裝到 tuple 中)\n\u003c/pre\u003e"