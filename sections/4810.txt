var __v="\u003cpre class='k-pre'\u003eCond 通過一個關聯的 Locker(通常是一個 *Mutex 或 *RWMutex) 實現了一個 條件變量\n\n// 創建一個 Cond\nfunc NewCond(l Locker) *Cond\n\n// 等待 一個 通知 調用前 必須 Lock Locker\n// Wait 會先自動 Unlock Locker 之後使用 調用 Wait的 goroutine 阻塞 直到收到一個 通知\n// 當收到 通知 後 Wait 後嘗試 Lock Locker 如果 成功則 返回 否則 繼續阻塞 等待下個通知\nfunc (c *Cond) Wait()\n\n// 喚醒 一個 Wait 中的 goroutine\n// 調用 Signal 的goroutine 可以 Lock Locker 也可以 不 Lock\nfunc (c *Cond) Signal()\n\n// 喚醒 所有 Wait 中的 goroutine\n// 調用 Broadcast 的goroutine 可以 Lock Locker 也可以 不 Lock\nfunc (c *Cond) Broadcast()\n\u003c/pre\u003e\n\u003cpre class='prettyprint linenums'\u003epackage main\n\nimport (\n\t\"log\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tcond := sync.NewCond(\u0026amp;sync.Mutex{})\n\n\tgo func() {\n\t\ttime.Sleep(time.Second)\n\t\t// 喚醒 等待的 goroutine\n\t\tlog.Println(\"1\")\n\t\tcond.Signal()\n\t\twg.Done()\n\t}()\n\n\tgo func() {\n\t\t//time.Sleep(time.Second)\n\t\tcond.L.Lock()\n\t\tlog.Println(\"0\")\n\t\tcond.Wait()\n\t\tlog.Println(\"2\")\n\t\tcond.L.Unlock()\n\n\t\twg.Done()\n\t}()\n\n\twg.Wait()\n\tlog.Println(\"end\")\n}\n\u003c/pre\u003e"