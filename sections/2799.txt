var __v="\u003cpre class=\"k-pre\"\u003e\u003cstrong\u003e方法一\n在主程序中 調用 AfxSetResourceHandle 設置資源模板\u003c/strong\u003e\n\u003cpre class='prettyprint linenums'\u003eHINSTANCE exe=GetModuleHandle(NULL),\ndll=GetModuleHandle(L\"dll.dll\");\n//設置從dll加載資源\nAfxSetResourceHandle(dll);\nMyDialgg* dialg=new MyDialgg();\ndialg-\u0026gt;Create(MyDialgg::IDD,this);\n//恢復默認(既從exe加載)\nAfxSetResourceHandle(exe);\nif(dialg)\n{\ndialg-\u0026gt;SetWindowPos(0,0,0,0,0,SWP_NOZORDER|SWP_NOSIZE|SWP_SHOWWINDOW);\n}\u003c/pre\u003e\n\u003cstrong\u003e方法二\n在dll中 調用 AfxSetResourceHandle 設置資源模板\u003c/strong\u003e\n\u003cpre class='prettyprint linenums'\u003e\t//獲取當前模板句柄\nHINSTANCE old=AfxGetResourceHandle();\n//設置以dll句柄為模板句柄\nAfxSetResourceHandle(theApp.m_hInstance);\n//調用 要使用資源的代碼\nCreate(MyDialgg::IDD,cwnd);\n\n//恢復原值\nAfxSetResourceHandle(old);\u003c/pre\u003e\n\n\u003cstrong\u003e方法三 此方法在debug下可能會應發一個斷言(此似乎是一個bug)\n在dll中 使用AFX_MANAGE_STATE(AfxGetStaticModuleState()) 宏\u003c/strong\u003e\n\u003cpre class='prettyprint linenums'\u003eAFX_MANAGE_STATE(AfxGetStaticModuleState())\nCreate(MyDialgg::IDD,cwnd);\n\u003c/pre\u003eAfxGetStaticModuleState() 函數將創建一個模塊全局實例類 AFX_MODULE_STATE\nAFX_MANAGE_STATE宏將 AFX_MODULE_STATE 中句柄 設置為資源模當前句柄\nAFX_MODULE_STATE的析構將 恢復原設置\n\n\u003cstrong\u003e方法四\n鑑於方法三的 合理性 但bug的存在 大可以 自己定義個類似的機制\u003c/strong\u003e\n\u003cpre class='prettyprint linenums'\u003e//dll.hpp\n#ifndef _DARK_DLL_\n#define _DARK_DLL_\nnamespace dark\n{\n\tnamespace dll\n\t{\n\t\tclass SetResourceHandle\n\t\t{\n\t\tpublic:\n\t\t\tHINSTANCE old;\n\t\t\t//構造設置資源句柄\n\t\t\tSetResourceHandle(HINSTANCE hinstance)\n\t\t\t{\n\t\t\t\told=AfxGetResourceHandle();\n\t\t\t\tAfxSetResourceHandle(hinstance);\n\t\t\t}\n\t\t\t//析構恢復資源句柄\n\t\t\t~SetResourceHandle()\n\t\t\t{\n\t\t\t\tAfxSetResourceHandle(old);\n\t\t\t}\n\t\t};\n\t}\n}\n#endif\t//dll\n\n\n\n//實例化 設置 恢復 資源句柄\ndark::dll::SetResourceHandle resource_handle(theApp.m_hInstance);\nCreate(MyDialgg::IDD,cwnd);\u003c/pre\u003e\n\u003c/pre\u003e"