var __v="\u003cpre class=\"k-pre\"\u003eSTEP\t1\n鏡子中 的 圖像 只不過是 真實圖像的一個 倒影\n所以 要實現鏡面效果 首先是 計算出 倒影的 位置\n\n使用\n D3DXMATRIX * D3DXMatrixReflect(\n  __inout  D3DXMATRIX *pOut,\n  __in     const D3DXPLANE *pPlane\n);\n返回 一個 倒影變換矩陣\n使用 原變換矩陣 * 倒影變換矩陣 = 變換矩陣\n(變換矩陣 為 原變換矩陣 的倒影)\n \nSTEP\t2\n繪製倒影時 倒影的點順序 和原模型 方向相反 這會導致 正面被誤認為背面\n故此時還需要 修改 消影方式\nHRESULT SetRenderState(\n  [in]  D3DRENDERSTATETYPE State,\t//D3DRS_CULLMODE(設置消影 方式)\n  [in]  DWORD Value\t\t\t\t\t\n);\nvalue 取值\nD3DCULL_NONE\t//完全禁用 消影\nD3DCULL_CW\t\t//只對順時針繞序的三角形單位 消影 \nD3DCULL_CCW\t\t//(默認值) 只對逆時針繞序的三角形單位 消影\n\nSTEP\t3\n此時 倒影處於 鏡子之後 故會被 鏡子擋住而不進行渲染 \n故需要 禁用深度緩存 使倒影得到渲染\ndevice_ptr_-\u0026gt;SetRenderState(D3DRS_ZENABLE,FALSE);\n繪製後 需要恢復深度緩存\ndevice_ptr_-\u0026gt;SetRenderState(D3DRS_ZENABLE,TRUE);\n\t\n\t    \nSTEP\t4\n此時 倒影的 成像 和 鏡子的 成像 位於同一位置 還需要設置 融合效果\n使倒影的位置 只有 倒影的像素\ndevice_ptr_-\u0026gt;SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);\ndevice_ptr_-\u0026gt;SetRenderState(D3DRS_SRCBLEND,  D3DBLEND_DESTCOLOR);\ndevice_ptr_-\u0026gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);\n\u003c/pre\u003e"