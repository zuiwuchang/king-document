var __v="\u003cpre class=\"k-pre\"\u003e//CreateThread後 線程核心對象計數最少為2 因為 CreateThread使其+1(返回的HANDLE被線程擁有) 線程本身亦(擁有此核心對象)+1 \n//故要線程結束 且 CloseHandle 一次之後 線程核心對象才被清除\n\n\u003cstrong\u003e//創建線程\u003c/strong\u003e\nHANDLE WINAPI CreateThread(\t\t\t\t\t//失敗返回 FALSE 否則返回線程句柄\t\n\t__in_opt   LPSECURITY_ATTRIBUTES lpThreadAttributes,\t\t//安全描述符 一般為NULL\n\t__in       SIZE_T dwStackSize,\t\t\t\t//新線程擁有自己的堆棧 0表示默認(1MB)\n\t__in       LPTHREAD_START_ROUTINE lpStartAddress,\t\t//新線程起始地址\n\t__in_opt   LPVOID lpParameter,\t\t\t\t//傳入線程參數\n\t__in       DWORD dwCreationFlags,\t\t\t\t//允許產生一個暫時掛起的線程 0(立即執行) CREATE_SUSPENDED(掛起)\n\t__out_opt  LPDWORD lpThreadId\t\t\t\t\t//返回線程id 可為NULL\t由於安全考慮 未提供由id到handle的取得方法\n);\tPostThreadMessage\tAttachThreadInput\n\n\u003cstrong\u003e//線程函數聲明\u003c/strong\u003e\nDWORD WINAPI ThreadProc(\n\t__in  LPVOID lpParameter\n);\n\n\n\u003cstrong\u003e//使一個核心對象 引用計數減1\u003c/strong\u003e\nBOOL WINAPI CloseHandle(\n\t__in  HANDLE hObject\n);\n\n\n//獲取線程返回代碼\nBOOL WINAPI GetExitCodeThread(\n\t__in   HANDLE hThread,\n\t__out  LPDWORD lpExitCode\t\t//返回線程函數的返回值 若線程未結束返回STILL_ACTIVE  259\n);\n\n//強制結束當前線程\t不推薦 這不會釋放線程資源 之後線程的任何代碼都無法執行\nVOID WINAPI ExitThread(\n\t__in  DWORD dwExitCode\t\t//指定線程退出碼\n);\n\n//恢復線程\nDWORD WINAPI ResumeThread(\n\t__in  HANDLE hThread\n);\n\n//掛起線程\nDWORD WINAPI SuspendThread(\n\t__in  HANDLE hThread\n);\n\u003c/pre\u003e"