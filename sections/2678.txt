var __v="\u003cpre class=\"prettyprint linenums\"\u003e#include \u0026lt;cstdint\u0026gt;\n\n#include \u0026lt;boost/asio.hpp\u0026gt;\n#include \u0026lt;boost/thread.hpp\u0026gt;\n#include \u0026lt;boost/smart_ptr.hpp\u0026gt;\n#include \u0026lt;boost/asio/spawn.hpp\u0026gt;\n#include \u0026lt;boost/bind.hpp\u0026gt;\n\n#define LISTEN_ADDRESS \"0.0.0.0\"\n#define LISTEN_PORT 8080\n#define BUFFER_SIZE 1024\n#define COMPARE_GET 50\n\n\ntypedef boost::asio::io_service io_service_t;\ntypedef boost::asio::ip::tcp::acceptor acceptor_t;\ntypedef boost::asio::ip::tcp::socket socket_t;\ntypedef boost::shared_ptr\u0026lt;socket_t\u0026gt; socket_spt;\n\nvoid coroutine_read(socket_spt sp,std::size_t* client,boost::asio::yield_context ctx);\nclass server_t\n{\npublic:\n    //listen\n    io_service_t _service;\n    acceptor_t _acceptor;\n    //read\n    io_service_t* _services = NULL;\n    std::size_t* _clients = NULL;\n    std::size_t _n = 0;\n    std::size_t _flag = COMPARE_GET;\n    std::size_t _pos = 0;\n\n    server_t()\n        :_acceptor(_service,boost::asio::ip::tcp::endpoint(boost::asio::ip::address::from_string(LISTEN_ADDRESS),LISTEN_PORT))\n    {\n        std::size_t n = boost::thread::hardware_concurrency();\n        _n = n;\n        _services = new io_service_t[n];\n        _clients = new std::size_t[n];\n        for(std::size_t i=0; i\u0026lt;n; ++i)\n        {\n            _clients[i] = 0;\n            boost::thread([services=_services,i=i]()\n            {\n                boost::asio::deadline_timer timer(services[i],boost::posix_time::hours(24 * 365 * 10));\n                timer.async_wait([](const boost::system::error_code\u0026amp; e) {});\n                services[i].run();\n            });\n        }\n    }\n    ~server_t()\n    {\n        if(_services)\n        {\n            delete[] _services;\n        }\n        if(_clients)\n        {\n            delete[] _clients;\n        }\n    }\n    void run()\n    {\n        post_accept();\n        std::cout\u0026lt;\u0026lt;\"work at \"\u0026lt;\u0026lt;LISTEN_ADDRESS\u0026lt;\u0026lt;\":\"\u0026lt;\u0026lt;LISTEN_PORT\u0026lt;\u0026lt;std::endl;\n        _service.run();\n    }\n    void post_accept()\n    {\n        std::size_t i = get_service();\n\n        socket_spt sock = boost::make_shared\u0026lt;socket_t\u0026gt;(_services[i]);\n        _acceptor.async_accept(*sock,\n                               boost::bind(\u0026amp;server_t::post_accept_handler,\n                                           this,\n                                           boost::asio::placeholders::error,\n                                           sock,\n                                           \u0026amp;_clients[i])\n                              );\n    }\n    std::size_t get_service()\n    {\n        if(_flag)\n        {\n            --_flag;\n             return _pos;\n        }\n\n        std::size_t min = _clients[0];\n        _pos = 0;\n        for(std::size_t i=1; i\u0026lt;_n; ++i)\n        {\n            if(_clients[i] \u0026lt; min)\n            {\n                min = _clients[i];\n                _pos = i;\n            }\n        }\n        _flag = COMPARE_GET - 1;\n         return _pos;\n    }\n    void post_accept_handler(const boost::system::error_code\u0026amp; ec,socket_spt sock,std::size_t* client)\n    {\n        post_accept();\n        if(ec)\n        {\n            return;\n        }\n\n        io_service_t\u0026amp; service = sock-\u0026gt;get_io_service();\n        service.post([client=client]()\n        {\n            ++(*client);\n        });\n\n        //爲 socket 啓動 通信 coroutine\n        boost::asio::spawn(service,boost::bind(coroutine_read,sock,client,_1));\n    }\n};\n\nint main()\n{\n    try\n    {\n        server_t s;\n        s.run();\n    }\n    catch(const std::bad_alloc\u0026amp; e)\n    {\n        std::cout\u0026lt;\u0026lt;e.what()\u0026lt;\u0026lt;std::endl;\n    }\n    catch(const boost::system::system_error\u0026amp; e)\n    {\n        std::cout\u0026lt;\u0026lt;e.what()\u0026lt;\u0026lt;std::endl;\n    }\n    return 0;\n}\n\nvoid coroutine_read(socket_spt sp,std::size_t* client,boost::asio::yield_context ctx)\n{\n    boost::system::error_code ec;\n    socket_t\u0026amp; s = *sp;\n    try\n    {\n        //讀取消息\n        std::uint8_t buffer[BUFFER_SIZE];\n        std::size_t pos = 0;\n        while(pos \u0026lt; BUFFER_SIZE)\n        {\n            //接收消息 yield\n            std::size_t n = s.async_read_some(boost::asio::buffer(buffer + pos,BUFFER_SIZE - pos),ctx);\n            pos += n;\n            if(buffer[pos-1] == '\\n')\n            {\n                //echo\n                s.async_write_some(boost::asio::buffer(buffer,pos),ctx);\n                break;\n            }\n        }\n\n        //退出 關閉 socket\n    }\n    catch(const boost::system::system_error\u0026amp; se)\n    {\n        std::cout\u0026lt;\u0026lt;se.what()\u0026lt;\u0026lt;\"\\n\";\n    }\n\n    s.shutdown(socket_t::shutdown_both,ec);\n    s.close(ec);\n\n    --(*client);\n}\n\u003c/pre\u003e"