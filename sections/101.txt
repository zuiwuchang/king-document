var __v="\n\u003cpre class='prettyprint linenums'\u003epackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\n\tarrs := createRand(10, 100)\n\tnow := time.Now()\n\tfmt.Println(\"src\t\t\", arrs)\n\tfmt.Println(\"IsOrt\t\", isSort(arrs))\n\t//insertSort(arrs)\n\tinsertSortBinarySearch(arrs)\n\tfmt.Println(\"sort\t\", arrs)\n\tfmt.Println(\"IsOrt\t\", isSort(arrs))\n\tfmt.Println(time.Now().Sub(now))\n}\n\n//創建 n個 [0,end) 的隨機 slice\nfunc createRand(n, end int) []int {\n\trand.Seed(time.Now().Unix())\n\n\tarrs := make([]int, n, n)\n\tfor i := 0; i \u0026lt; n; i++ {\n\t\tarrs[i] = rand.Intn(end)\n\t}\n\treturn arrs\n}\n\n//返回 slice 是否 升序排列\nfunc isSort(arrs []int) bool {\n\tfor i := 0; i \u0026lt; len(arrs)-1; i++ {\n\t\tif arrs[i] \u0026gt; arrs[i+1] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n//插入排序 可以 原址排序\nfunc insertSort(arrs []int) {\n\t//第0個已經插好 故從第一個開始 插入\n\tfor i := 1; i \u0026lt; len(arrs); i++ {\n\t\t//待插入的牌\n\t\tkey := arrs[i]\n\t\tj := i\n\t\tfor j \u0026gt; 0 \u0026amp;\u0026amp; arrs[j-1] \u0026gt; key {\n\t\t\t//如果 比當前牌大 將牌後移\n\t\t\tarrs[j] = arrs[j-1]\n\t\t\tj--\n\t\t}\n\t\tif j != i {\n\t\t\t//插入牌\n\t\t\tarrs[j] = key\n\t\t}\n\t}\n}\n\n//優化的插入排序 (使用 二分查找 尋找 插入位置)\nfunc insertSortBinarySearch(arrs []int) {\n\tfor i := 1; i \u0026lt; len(arrs); i++ {\n\t\tkey := arrs[i]\n\n\t\t//插入位置\n\t\tpos := i\n\n\t\t//二分查找 插入位置\n\t\tlow := 0\n\t\thigh := i - 1\n\t\tfor low \u0026lt;= high {\n\t\t\tmid := low + (high-low)/2\n\t\t\tcompare := arrs[mid]\n\n\t\t\tif compare == key {\n\t\t\t\tpos = mid\n\t\t\t\tbreak\n\t\t\t} else if compare \u0026lt; key {\n\t\t\t\tlow = mid + 1\n\t\t\t} else {\n\t\t\t\tpos = mid\n\t\t\t\thigh = mid - 1\n\t\t\t}\n\t\t}\n\n\t\t//當前位置 爲插入位置\n\t\tif pos == i {\n\t\t\tcontinue\n\t\t}\n\n\t\t//插入\n\t\tfor index := i; index \u0026gt; pos; index-- {\n\t\t\tarrs[index] = arrs[index-1]\n\t\t}\n\t\tarrs[pos] = key\n\t}\n}\n\u003c/pre\u003e"