var __v="\n\u003cpre class='prettyprint linenums'\u003etypedef struct _USER_DATA_\n{\n\tstd::fstream fstream;\n\tunsigned int write_sum;\n\tunsigned int data_size;\n\tbool init;\n\tchar buffer[BUFFER_LEN];\n\t_USER_DATA_()\n\t{\n\t\tinit=false;\n\t\twrite_sum\t\t=\t0;\n\t\tdata_size\t=\t0;\n\t}\n\t~_USER_DATA_()\n\t{\n\t\tif(fstream.is_open())\n\t\t{\n\t\t\tfstream.close();\n\t\t}\n\t}\n\n\tvoid load(const std::wstring\u0026amp; file_path)\n\t{\n\t\tif(fstream.is_open())\n\t\t{\n\t\t\tfstream.close();\n\t\t\tfstream.clear();\n\t\t}\n\t\t\n\t\tfstream.open(file_path,std::ios::out|std::ios::in|std::ios::binary);\n\t\t\n\t\tfstream.seekg(0,std::ios::end);\n\t\tdata_size=(unsigned int)fstream.tellg();\n\t\tdata_size-=(unsigned int)128;\n\t\tfstream.seekg(0,std::ios::beg);\n\n\t\tstd::fstream::pos_type t=fstream.tellg();\n\t\tint x=0;\n\t\t++x;\n\t}\n}USER_DATA,*LUSER_DATA;\n\n\nenum mad_flow input_fun(void* lParam,mad_stream* stream)\n{\n\tLUSER_DATA data=(LUSER_DATA)lParam;\n\n\tif(data-\u0026gt;data_size \u0026gt; data-\u0026gt;write_sum)\n\t{\n\t\t//未解壓數據大小\n\t\tint un_size\t=\tstream-\u0026gt;bufend-stream-\u0026gt;next_frame;\n\t\t//解壓數據大小\n\t\tint de_size\t=\tBUFFER_LEN - un_size;\n\n\t\tif(data-\u0026gt;init)\n\t\t{\n\t\t\tdata-\u0026gt;write_sum+=de_size;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdata-\u0026gt;init=true;\n\t\t}\n\n\t\tif(un_size)\n\t\t{\n\t\t\t//更新代解碼緩衝區\n\t\t\tmemcpy(data-\u0026gt;buffer\n\t\t\t\t,data-\u0026gt;buffer + de_size\n\t\t\t\t,un_size);\n\t\t}\n\n\t\tdata-\u0026gt;fstream.read(data-\u0026gt;buffer + un_size , de_size);\n\t\t\n\n\t\t//mad_stream_buffer 指定要解碼數據 和 數據大小\n\t\tmad_stream_buffer(stream,(const unsigned char *)data-\u0026gt;buffer ,  BUFFER_LEN);\n\n\t\t//繼續下次解碼\n\t\treturn MAD_FLOW_CONTINUE ;\n\t}\n\n\t//解碼完成停止操作\n\treturn MAD_FLOW_STOP;\n}\n\nstd::fstream f(\"爱是没余地.wav\",std::ios::out|std::ios::in|std::ios::binary|std::ios::trunc);\n//量化為16位精度數據\nint scale(mad_fixed_t sample)\n{\n    /* round */\n    sample += (1L \u0026lt;\u0026lt; (MAD_F_FRACBITS - 16));\n\n    /* clip */\n    if (sample \u0026gt;= MAD_F_ONE)\n        sample = MAD_F_ONE - 1;\n    else if (sample \u0026lt; -MAD_F_ONE)\n        sample = -MAD_F_ONE;\n\n    /* quantize */\n    return sample \u0026gt;\u0026gt; (MAD_F_FRACBITS + 1 - 16);\n}\n\n//保存解碼數據\nenum mad_flow output_fun(void *,\n\t\t\t\t\tmad_header const * header,\n\t\t\t\t\tmad_pcm* pcm)\n{\n\tunsigned int nchannels, nsamples;\n \n\t// pcm-\u0026gt;samplerate contains the sampling frequency\n\n\tint sample;\n\tfor(int i=0\n\t\t;ilength\t//聲道信息數組長度\n\t\t;++i)\n\t{\n         \n       sample =scale( pcm-\u0026gt;samples[0][i]);\n\t   sample \u0026amp;= 0xFFFF;\n\t   f.write((char*)\u0026amp;sample,2);\n\n\t   //雙聲道 寫入另外一個聲道數據\n\t   if (2\t==\tpcm-\u0026gt;channels)\n\t   {\n\t\t   sample =scale( pcm-\u0026gt;samples[1][i]);\n\t\t   sample \u0026amp;= 0xFFFF;\n\t\t   f.write((char*)\u0026amp;sample,2);\n\t   }\n    }\n\t\n\treturn MAD_FLOW_CONTINUE ;\t\t\n}\nint _tmain(int argc, _TCHAR* argv[])\n{\n\t\n\tUSER_DATA data;\n\tdata.load(L\"爱是没余地.mp3\");\n\t\n\n\tunsigned int err_code=0;\n\n\t//定義一個解碼器\n\tmad_decoder decoder;\n\t//初始化解碼器\n\tmad_decoder_init(\u0026amp;decoder\t//解碼器指針\n\t\t,\u0026amp;data\t\t\t\t\t//傳遞給所有回調函數的自定義參數\n\t\t,input_fun\t\t\t\t//用以指定代解碼數據的回調函數\n\t\t,0\t\t\t\t\t\t//處理返回解碼後每針 頭部信息\n\t\t,0\n\t\t,output_fun\t\t\t\t//用以返回解碼後每針 頭部信息 和解碼後的PCM數據\n\t\t,0\n\t\t,0\n\t\t);\n\n\tboost::timer t;\n\n\t//執行解碼\n\terr_code = mad_decoder_run(\u0026amp;decoder, MAD_DECODER_MODE_SYNC);\n\n\tstd::cout\u0026lt;\u0026lt;t.elapsed()\u0026lt;\u0026lt;std::endl;\n\n\t//釋放資源\n\tmad_decoder_finish(\u0026amp;decoder);\n\n\tstd::system(\"pause\");\n\treturn 0;\n}\u003c/pre\u003e"