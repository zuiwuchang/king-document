var __v="\n\u003cpre class='prettyprint linenums'\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;cstring\u0026gt;\n\nclass animal_t\n{\nprotected:\n    std::string _name;\n\npublic:\n    animal_t(const std::string\u0026amp; name):_name(name)\n    {\n\n    }\n\n};\nstd::string make_like()\n{\n    puts(\"make_like\");\n    return \"sleep and eat\";\n}\nclass cat_t : public animal_t\n{\nprotected:\n    //聲明時 初始化 值\n    std::string _like = make_like();\npublic:\n    using animal_t::animal_t;\n\n    //調用其他 構造函數\n    cat_t():cat_t(\"cat\")\n    {\n\n    }\n\n    /*錯誤 和 繼承的 構造函數 同簽名 造成 重定義\n    cat_t(const std::string\u0026amp; name)\n    {\n\n    }\n    */\n\n    //不使用 聲明時 定義的 like 值\n    //此時 不能 調用 cat_t(name) 任何一個 構造函數 完成 都代表 對象構造完成\n    //成員變量 需要在 構造完成 時被正確初始化\n    cat_t(const std::string\u0026amp; name,const std::string\u0026amp; like):animal_t(name),_like(like)\n    {\n\n    }\n    void speak()\n    {\n        std::cout\u0026lt;\u0026lt;\"i'm \"\u0026lt;\u0026lt;_name\u0026lt;\u0026lt;\"\\n\"\n        \u0026lt;\u0026lt;\"i like \"\u0026lt;\u0026lt;_like\u0026lt;\u0026lt;\"\\n\";\n    }\n};\nint main()\n{\n    //使用 繼承的 構造函數\n    cat_t garfield(\"Garfield\");\n    garfield.speak();\n\n    cat_t cat;\n    cat.speak();\n\n    //make_like 不會被調用\n    cat_t cat1(\"Cat\",\"eat\");\n    cat1.speak();\n\n    return 0;\n}\u003c/pre\u003e"