var __v="\u003cpre class='k-pre'\u003e主要通過 qt 的 信號插槽 機制\n(使用 qt 提供的 修改 qml結構api亦可 然那何必還要用 qml)\u003c/pre\u003e\n\n\u003col\u003e\n\u003cli\u003e參考 qtmoc 的介紹 用go定義一個 qt 子類\u003c/li\u003e\n\u003cli\u003e實例化 此類 並設置爲 qml 的上下文中\u003cpre class='prettyprint linenums'\u003epackage main\n\nimport (\n\t\"github.com/therecipe/qt/core\"\n\t\"github.com/therecipe/qt/gui\"\n\t\"github.com/therecipe/qt/qml\"\n\t\"github.com/therecipe/qt/quickcontrols2\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Create application\n\tapp := gui.NewQGuiApplication(len(os.Args), os.Args)\n\n\t// Enable high DPI scaling\n\tapp.SetAttribute(core.Qt__AA_EnableHighDpiScaling, true)\n\n\t// Use the material style for qml\n\tquickcontrols2.QQuickStyle_SetStyle(\"material\")\n\n\t// Create a QML application engine\n\tengine := qml.NewQQmlApplicationEngine(nil)\n\n\t//實例化 類\n\tbridge := NewExampleStruct(nil)\n\tdefer bridge.DestroyExampleStruct()\n\t//將 實例化 設置爲 qml 環境\n\tengine.RootContext().SetContextProperty(\"bridge\", bridge)\n\n\t// Load the main qml file\n\tengine.Load(core.NewQUrl3(\"qrc:/qml/main.qml\", 0))\n\n\t// Execute app\n\tgui.QGuiApplication_Exec()\n}\n\u003c/pre\u003e\u003c/li\u003e\n\u003cli\u003e所有 定義的 signal go可以直接作爲 函數 調用 qml 會得到一個 同名的 signal 通知\u003c/li\u003e\n\u003cli\u003e所有 定義的 slot qml 可以直接作爲 函數 調用 go 會得到一個  同名的 signal 通知\u003c/li\u003e\n\u003cli\u003e屬性 規則就和 qt 屬性 一樣 只是 go不要直接 操作 此屬性 而是使用 getter + setter 操作\u003c/li\u003e\n\u003c/ol\u003e"