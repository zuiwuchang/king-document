var __v="\u003cpre class='k-pre'\u003egoalng 亦提供了 解析 xml stream 的支持\u003c/pre\u003e\n\u003cpre class='prettyprint linenums'\u003epackage main\n\nimport (\n\t\"encoding/xml\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\nconst (\n\t// InputFile .\n\tInputFile = \"a.xml\"\n)\n\nfunc main() {\n\t// 創建 解碼流\n\tf, e := os.Open(InputFile)\n\tif e != nil {\n\t\tlog.Fatalln(e)\n\t}\n\tdecoder := xml.NewDecoder(f)\n\n\tfor {\n\t\t// 獲取 token\n\t\tt, e := decoder.Token()\n\t\tif e != nil {\n\t\t\tif e == io.EOF {\n\t\t\t\tlog.Println(\"Parse XML finished!\")\n\t\t\t} else {\n\t\t\t\tlog.Fatalln(e)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\t// decoder.Token() 返回的 token 只在下次調用 Token() 前有效\n\t\t// CopyToken 可以創建一個 一直有效的 副本\n\t\t// t = xml.CopyToken(t)\n\n\t\t// 處理 token\n\t\tswitch t := t.(type) {\n\t\tcase xml.StartElement:\n\t\t\tlog.Printf(\"StartElement: \u0026lt;%v\u0026gt;\\n\", t.Name.Local)\n\t\tcase xml.EndElement:\n\t\t\tlog.Printf(\"EndElement: \u0026lt;%v\u0026gt;\\n\", t.Name.Local)\n\t\tcase xml.CharData:\n\t\t\tlog.Printf(\"CharData: %v\\n\", string(t))\n\t\tcase xml.Comment:\n\t\t\tlog.Printf(\"Comment: \u0026lt;!--%v--\u0026gt;\\n\", string(t))\n\t\t}\n\t}\n}\n\u003c/pre\u003e"