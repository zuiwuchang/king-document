var __v="\u003cpre class=\"k-pre\"\u003ezlib 使用 deflate 抽象流 zlib gzip 算法\n只需要 使用 deflateInit2/inflateInit2 替換掉 deflateInit/inflateInit 即可\n\u003c/pre\u003e\n\u003cpre class='prettyprint linenums'\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;cstdint\u0026gt;\n#include \u0026lt;zlib/zlib.h\u0026gt;\n#include \u0026lt;cassert\u0026gt;\n\nint gzip_compress(uint8_t* in_data, size_t in_data_size, std::vector\u0026lt;uint8_t\u0026gt; \u0026amp;out_data)\n{\n    //壓縮 返回值\n    std::vector\u0026lt;uint8_t\u0026gt; buffer;\n\n    //壓縮 緩衝區\n    const size_t BUFSIZE = 1024 * 8;\n    uint8_t temp_buffer[BUFSIZE];\n\n    //創建 zlib 流\n    z_stream strm;\n    //使用默認 內存 策略\n    strm.zalloc = 0;\n    strm.zfree = 0;\n    //設置待壓縮 數據\n    strm.next_in = in_data;\n    strm.avail_in = in_data_size;\n    //輸出 緩衝區\n    strm.next_out = temp_buffer;\n    strm.avail_out = BUFSIZE;\n\n    //使用壓縮等級 Z_BEST_COMPRESSION 初始化 流\n    int rs = deflateInit2(\u0026amp;strm, Z_BEST_COMPRESSION,Z_DEFLATED,MAX_WBITS + 16,8,Z_DEFAULT_STRATEGY);\n    if(rs != Z_OK)\n    {\n        return rs;\n    }\n\n    //如果存在 待壓縮數據\n    while (0 != strm.avail_in)\n    {\n        //使用 zlib 壓縮數據\n        rs = deflate(\u0026amp;strm, Z_NO_FLUSH);\n        if(Z_OK != rs)\n        {\n            //釋放 strm\n            deflateEnd(\u0026amp;strm);\n            return rs;\n        }\n\n        //輸出 緩衝區 已滿\n        if (0 == strm.avail_out)\n        {\n            //copy 輸出數據\n            buffer.insert(buffer.end(), temp_buffer, temp_buffer + BUFSIZE);\n\n            //重新 設置 輸出數據\n            strm.next_out = temp_buffer;\n            strm.avail_out = BUFSIZE;\n        }\n    }\n\n\n    while (Z_OK == rs)\n    {\n        //輸出 緩衝區 已滿\n        if (0 == strm.avail_out)\n        {\n            //copy 輸出數據\n            buffer.insert(buffer.end(), temp_buffer, temp_buffer + BUFSIZE);\n\n            //重新 設置 輸出數據\n            strm.next_out = temp_buffer;\n            strm.avail_out = BUFSIZE;\n        }\n\n        //壓縮 結束\n        rs = deflate(\u0026amp;strm, Z_FINISH);\n    }\n    if(rs != Z_STREAM_END)\n    {\n        //釋放 strm\n        deflateEnd(\u0026amp;strm);\n        return rs;\n    }\n\n    //copy\n    buffer.insert(buffer.end(), temp_buffer, temp_buffer + BUFSIZE - strm.avail_out);\n\n    //釋放 strm\n    deflateEnd(\u0026amp;strm);\n\n    //返回壓縮數據\n    out_data.swap(buffer);\n\n    return Z_OK;\n}\n\nint gzip_uncompress(uint8_t* in_data, size_t in_data_size, std::vector\u0026lt;uint8_t\u0026gt; \u0026amp;out_data)\n{\n    //解壓 返回值\n    std::vector\u0026lt;uint8_t\u0026gt; buffer;\n\n    //解壓 緩衝區\n    const size_t BUFSIZE = 1024 * 8;\n    uint8_t temp_buffer[BUFSIZE];\n\n    //創建 zlib 流\n    z_stream strm;\n    //使用默認 內存 策略\n    strm.zalloc = 0;\n    strm.zfree = 0;\n    //設置待解壓 數據\n    strm.next_in = in_data;\n    strm.avail_in = in_data_size;\n    //輸出 緩衝區\n    strm.next_out = temp_buffer;\n    strm.avail_out = BUFSIZE;\n\n    //初始化 解壓 流\n    int rs = inflateInit2(\u0026amp;strm,MAX_WBITS + 32);\n    if(rs != Z_OK)\n    {\n        return rs;\n    }\n\n    //如果存在 待解壓數據\n    while (0 != strm.avail_in)\n    {\n        //使用 zlib 解壓數據\n        rs = inflate(\u0026amp;strm, Z_NO_FLUSH);\n        if(Z_STREAM_END == rs)\n        {\n            rs = Z_OK;\n            break;\n        }\n        if(Z_OK != rs)\n        {\n            //釋放 strm\n            inflateEnd(\u0026amp;strm);\n            return rs;\n        }\n\n        //輸出 緩衝區 已滿\n        if (0 == strm.avail_out)\n        {\n            //copy 輸出數據\n            buffer.insert(buffer.end(), temp_buffer, temp_buffer + BUFSIZE);\n\n            //重新 設置 輸出數據\n            strm.next_out = temp_buffer;\n            strm.avail_out = BUFSIZE;\n        }\n    }\n    while (Z_OK == rs)\n    {\n        //輸出 緩衝區 已滿\n        if (0 == strm.avail_out)\n        {\n            //copy 輸出數據\n            buffer.insert(buffer.end(), temp_buffer, temp_buffer + BUFSIZE);\n\n            //重新 設置 輸出數據\n            strm.next_out = temp_buffer;\n            strm.avail_out = BUFSIZE;\n        }\n\n        //解壓 結束\n        rs = inflate(\u0026amp;strm, Z_FINISH);\n    }\n    if(rs != Z_STREAM_END)\n    {\n        //釋放 strm\n        inflateEnd(\u0026amp;strm);\n        return rs;\n    }\n\n    //copy\n    buffer.insert(buffer.end(), temp_buffer, temp_buffer + BUFSIZE - strm.avail_out);\n\n    //釋放 strm\n    inflateEnd(\u0026amp;strm);\n\n    //返回壓縮數據\n    out_data.swap(buffer);\n\n    return Z_OK;\n}\n\n\nint main()\n{\n    //原文\n    std::string str = \"草泥馬 funcking 的 test\";\n    //壓縮後\n    std::vector\u0026lt;std::uint8_t\u0026gt; compress;\n    //解壓後\n    std::vector\u0026lt;std::uint8_t\u0026gt; uncompress;\n\n\n    assert(Z_OK == gzip_compress((std::uint8_t*)str.data(),str.size(),compress));\n    assert(Z_OK == gzip_uncompress(compress.data(),compress.size(),uncompress));\n    assert(std::string((char*)uncompress.data(),uncompress.size()) == str);\n\n    return 0;\n}\n\u003c/pre\u003e"